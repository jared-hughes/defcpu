{
  "version": 3,
  "sources": ["../../node_modules/base64-js/index.js", "../../node_modules/ieee754/index.js", "../../node_modules/buffer/index.js", "../../site/src/worker.ts", "../../site/src/line-number.mjs", "../../node_modules/@defasm/core/parser.js", "../../node_modules/@defasm/core/relocations.js", "../../node_modules/@defasm/core/utils.js", "../../node_modules/@defasm/core/statement.js", "../../node_modules/@defasm/core/bitfield.js", "../../node_modules/@defasm/core/operands.js", "../../node_modules/@defasm/core/shuntingYard.js", "../../node_modules/@defasm/core/symbols.js", "../../node_modules/@defasm/core/sections.js", "../../node_modules/@defasm/core/directives.js", "../../node_modules/@defasm/core/operations.js", "../../node_modules/@defasm/core/mnemonicList.js", "../../node_modules/@defasm/core/mnemonics.js", "../../node_modules/@defasm/core/instructions.js", "../../node_modules/@defasm/core/compiler.js", "../../defasm/cli-browser/elf.js", "../../defasm/cli-browser/files.js"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "import { InputConfigJSON } from \"./cm-extensions/input-config.js\";\nimport init, { OuterMachine, WebUnpredictables } from \"./defcpu_web.js\";\nimport { findInstructionFromOffset, linePosition } from \"./line-number.mjs\";\nimport {\n  MessageFromWorker,\n  MessageToWorker,\n  MsgRunCode,\n  Status,\n} from \"./messages.js\";\nimport { AssemblyState } from \"@defasm/core\";\nimport { createExecutable } from \"defasm-cli-browser\";\n\nlet wasmReady = false;\n\ninit().then(() => {\n  wasmReady = true;\n});\n\ntype AssemblyStateT = any;\n\nlet om: OuterMachine | undefined;\nlet state: AssemblyStateT | undefined;\nlet breakpoints: Set<bigint> = new Set();\nlet running = false;\n\nglobalThis.addEventListener(\"message\", (fullMsg) => {\n  const msg = fullMsg.data as MessageToWorker;\n  switch (msg.type) {\n    case \"run\":\n      startRunningCode(msg);\n      break;\n    case \"poll-status\":\n      if (!om || !state) {\n        console.warn(\"Poll while not running\");\n        return;\n      }\n      postMessageFromWorker({\n        type: \"status\",\n        status: getStatus(om, state),\n      });\n      break;\n    case \"halt\":\n      if (!om) {\n        console.warn(\"Halt while not running\");\n        return;\n      }\n      om.free();\n      om = undefined;\n      state = undefined;\n      break;\n    case \"pause\":\n      // Will really pause on the next `continueRunningCode`,\n      // which is probably the next queued event in the event loop.\n      running = false;\n      break;\n    case \"continue\":\n      running = true;\n      continueRunningCode(true);\n      break;\n    case \"single-step\":\n      singleStep();\n      break;\n    case \"set-breakpoints\":\n      setBreakpoints(msg.breakpointFroms);\n      break;\n    default:\n      msg satisfies never;\n      console.error(\"Unrecognized message type\", msg);\n      break;\n  }\n});\n\nfunction postMessageFromWorker(msg: MessageFromWorker) {\n  globalThis.postMessage(msg);\n}\n\nfunction setBreakpoints(breakpointFroms: number[]) {\n  if (!state) return;\n  breakpoints = new Set();\n  for (const from of breakpointFroms) {\n    const addr = findInstructionFromOffset(state, from);\n    if (addr === undefined) continue;\n    breakpoints.add(BigInt(addr));\n  }\n}\n\n/** For now, just assume it's UTF-8 output. */\nfunction arrToString(arr: Uint8Array): string {\n  const maxLen = 128 * 1024; // 128 KB\n  if (arr.length > maxLen) {\n    arr = arr.slice(0, maxLen);\n  }\n  return new TextDecoder(\"utf-8\").decode(arr);\n}\n\nfunction getStatus(om: OuterMachine, state: AssemblyStateT): Status {\n  // TODO: only send message if there's a change.\n  const rip = om.get_rip();\n  const linePos =\n    rip < Number.MAX_SAFE_INTEGER ? linePosition(state, Number(rip)) : null;\n  return {\n    stdout: arrToString(om.get_stdout()),\n    stderr: arrToString(om.get_stderr()),\n    registersStr: arrToString(om.get_registers_str()),\n    linePos,\n    fullStepCount: om.get_full_step_count(),\n  };\n}\n\nfunction startRunningCode(data: MsgRunCode) {\n  try {\n    running = true;\n    const ds = data.state;\n    state = new AssemblyState();\n    // state.compile may throw\n    state.compile(ds.doc, { haltOnError: true });\n    const elf = createExecutable(state);\n\n    // This clearly may throw\n    if (!wasmReady) {\n      throw new Error(\"Wasm module not yet loaded\");\n    }\n\n    setBreakpoints(ds.breakpoints);\n\n    if (om) {\n      om.free();\n    }\n    om = OuterMachine.init(\n      elf,\n      // argv\n      getArgv(ds.inputConfig),\n      // envp\n      getEnvp(ds.inputConfig),\n      // TODO-seed: proper seed\n      getInitUnp(ds.inputConfig)\n    );\n    setTimeout(() => continueRunningCode(false), 0);\n  } catch (e) {\n    postMessageFromWorker({\n      type: \"error\",\n      error: `Error when running: ${e}`,\n    });\n  }\n}\n\nfunction getArgv(ic: InputConfigJSON) {\n  let argv;\n  try {\n    argv = JSON.parse(ic.argv);\n  } catch (e) {\n    throw new Error(\"Invalid argv JSON.\");\n  }\n  if (!Array.isArray(argv) || argv.some((e) => typeof e !== \"string\")) {\n    throw new Error(\"Argv should be a JSON array of strings.\");\n  }\n  argv.unshift(ic.arg0);\n  return argv;\n}\n\nfunction getEnvp(ic: InputConfigJSON) {\n  let envp;\n  try {\n    envp = JSON.parse(ic.envp);\n  } catch (e) {\n    throw new Error(\"Invalid envp JSON.\");\n  }\n  if (!Array.isArray(envp) || envp.some((e) => typeof e !== \"string\")) {\n    throw new Error(\"Envp should be a JSON array of strings.\");\n  }\n  return envp;\n}\n\nfunction getInitUnp(ic: InputConfigJSON) {\n  if (!ic.useFixed) {\n    return WebUnpredictables.from_random_seed(BigInt(ic.randomSeed));\n  }\n  return WebUnpredictables.from_fixed(\n    ic.vdsoPtr,\n    ic.rand16,\n    ic.execfnPtr,\n    ic.platformOffset\n  );\n}\n\nfunction checkDone() {\n  if (!om || !state) return;\n  if (om.is_done()) {\n    running = false;\n    postMessageFromWorker({\n      type: \"done\",\n      status: getStatus(om, state),\n    });\n    return true;\n  }\n}\n\nfunction checkBreakpoint() {\n  if (!om || !state) return;\n  if (breakpoints.has(om.get_rip())) {\n    running = false;\n    postMessageFromWorker({\n      type: \"pause\",\n      status: getStatus(om, state),\n    });\n    return true;\n  }\n}\n\nfunction singleStep() {\n  if (!om || !state) return;\n  if (checkDone()) return;\n  om.step();\n  if (checkDone()) return;\n  postMessageFromWorker({\n    type: \"pause\",\n    status: getStatus(om, state),\n  });\n}\n\nfunction continueRunningCode(firstAfterContinue: boolean) {\n  if (!om) return;\n  if (!running) {\n    return;\n  }\n  try {\n    if (checkDone()) return;\n    if (!firstAfterContinue) {\n      if (checkBreakpoint()) return;\n    }\n    for (let i = 0; i < 65536; i++) {\n      om.step();\n      if (checkDone()) return;\n      if (checkBreakpoint()) return;\n    }\n    setTimeout(() => continueRunningCode(false), 0);\n  } catch (e) {\n    postMessageFromWorker({\n      type: \"error\",\n      error: `Error when running: ${e}`,\n    });\n  }\n}\n", "/**\n * Char offset to RIP address of instruction.\n * @param {AssemblyState} state\n * @param {Number} from\n * @returns {Number | undefined}\n */\nexport function findInstructionFromOffset(state, from) {\n  let node = state.head.next;\n  while (node && node.statement.range.end < from) {\n    node = node.next;\n  }\n  if (node) {\n    const { statement } = node;\n    const sectionStart = statement.section.programHeader.p_vaddr;\n    const start = sectionStart + statement.address;\n    // statement.length gives the length in bytes.\n    return start;\n  } else {\n    return undefined;\n  }\n}\n\n// The following function `findInstruction` is from @defasm/core,\n// and `linePosition` is modified from `debug` from @defasm/core as well,\n// under the following license.\n// -\n// Copyright (c) 2021, Alon Ran\n// -\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n// -\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n/**\n * RIP address to section and instruction.\n * @param {AssemblyState} state\n * @param {Number} address\n */\nfunction findInstruction(state, address) {\n  for (const section of state.sections) {\n    const segment = section.programHeader;\n    if (\n      address >= segment.p_vaddr &&\n      address < Math.ceil((segment.p_vaddr + segment.p_memsz) / 0x1000) * 0x1000\n    ) {\n      const localAddress = address - segment.p_vaddr;\n      let node = section.head.next;\n      while (node) {\n        if (node.statement.length > 0 && node.statement.address >= localAddress)\n          return { section, instr: node.statement };\n        node = node.next;\n      }\n      return { section, instr: null };\n    }\n  }\n\n  return { section: null, instr: null };\n}\n\n/**\n * @param {AssemblyState} state\n * @param {Number} address\n */\nexport function linePositionStr(state, address) {\n  const pe = linePosition(state, address);\n  if (pe === null) return \"\";\n  const { pos, errLine } = pe;\n  return ` ${pos} line ${errLine}`;\n}\n\n/**\n * RIP address to line number.\n * @param {AssemblyState} state\n * @param {Number} address\n * @returns {{pos: \"on\" | \"after\", errLine: number}  | null}\n */\nexport function linePosition(state, address) {\n  let { instr: crashedInstr, section: crashedSection } = findInstruction(\n    state,\n    address\n  );\n  let pos = \"on\";\n  let errLine = null;\n  if (crashedInstr === null) {\n    if (crashedSection !== null) {\n      pos = \"after\";\n      state.iterate((instr, line) => {\n        if (instr.section === crashedSection) errLine = line;\n      });\n    }\n  } else {\n    state.iterate((instr, line) => {\n      if (errLine) return;\n      if (instr == crashedInstr) errLine = line;\n    });\n  }\n  return errLine === null ? null : { pos, errLine };\n}\n", "/**\n * @typedef {Object} Syntax\n * @property {boolean} intel\n * @property {boolean} prefix\n */\n\n/** @type {string} */          export var code;\n/** @type {boolean} */         export var comment;\n/** @type {RelativeRange} */   export var currRange;\n/** @type {Number} */          export var line;\n/** @type {RegExpExecArray} */ export var match;\n/** @type {RelativeRange} */   export var prevRange;\n/** @type {string} */          export var token;\n/** @type {Syntax?} */         export var currSyntax = null;\n\n/** @type {Range?} */\nvar parentRange = null;\n\n/** @param {Syntax} syntax */\nexport function setSyntax(syntax)\n{\n    currSyntax = syntax;\n}\n\nexport function startAbsRange()\n{\n    return parentRange = currRange.abs();\n}\n\nconst tokenizer = /([\"'])(\\\\(.|\\n|$)|[^\\\\])*?(\\1|$)|>>|<<|\\|\\||&&|>=|<=|<>|==|!=|[\\w.$]+|[\\S\\n]/g;\n\n/** @param {string} source */\nexport function loadCode(source, index = 0)\n{\n    tokenizer.lastIndex = index;\n    code = source;\n\n    line = (source.slice(0, index).match(/\\n/g) || []).length + 1;\n\n    next = defaultNext;\n    parentRange = currRange = new Range(index, 0);\n    match = 1; next();\n}\n\nvar defaultNext = () => {\n    prevRange = currRange;\n    if(!match) // Make sure not to loop around\n        return '\\n';\n    \n    comment = false;\n    match = tokenizer.exec(code);\n    if(match)\n    {\n        token = match[0];\n        currRange = new RelativeRange(parentRange, match.index, token.length);\n        if(token == (currSyntax.intel ? ';' : '#'))\n        {\n            comment = true;\n            token = ';';\n            tokenizer.lastIndex = code.indexOf('\\n', tokenizer.lastIndex);\n            if(tokenizer.lastIndex < 0)\n                tokenizer.lastIndex = code.length;\n            currRange.length = tokenizer.lastIndex - match.index;\n        }\n    }\n    else\n    {\n        token = '\\n';\n        currRange = new RelativeRange(parentRange, code.length, 1);\n    }\n\n    line += (token.match(/\\n/g) || []).length;\n    return token;\n}\n\nexport var next = defaultNext;\n\n// Highly unhygienic. You shouldn't put the token back on the stack after you touched it.\n// I recommend washing your hands after you use this thing.\nexport function ungetToken()\n{\n    let t = token, p = currRange, oldNext = next;\n    currRange = prevRange;\n    next = () => token = (next = oldNext, currRange = p, t);\n}\n\nexport function setToken(tok, range = currRange)\n{\n    token = tok || '\\n';\n    currRange = range;\n}\n\n\nexport class Range\n{\n    constructor(start = 0, length = 0)\n    {\n        if(start < 0 || length < 0)\n            throw `Invalid range ${start} to ${start + length}`;\n        this._start = start;\n        this.length = length;\n    }\n\n    /** @param {Number} pos */\n    includes(pos)\n    {\n        return this.end >= pos && pos >= this.start;\n    }\n\n    /** @param {Range} end */\n    until(end)\n    {\n        return new Range(this.start, end.end - this.start);\n    }\n\n    /** @param {string} text */\n    slice(text)\n    {\n        return text.slice(this.start, this.end);\n    }\n\n    get start() { return this._start; }\n    set start(val) { this._start = val; }\n\n    get end() { return this.start + this.length; }\n}\n\nexport class RelativeRange extends Range\n{\n    constructor(parent, start, length)\n    {\n        super(start - parent.start, length);\n        this.parent = parent;\n    }\n\n    get start() { return this.parent.start + this._start; }\n    set start(val) { this._start = val - this.parent.start; }\n\n    abs()\n    {\n        return new Range(this.start, this.length);\n    }\n\n    until(end)\n    {\n        return new RelativeRange(this.parent, this.start, end.end - this.start);\n    }\n}\n\nexport class ASMError\n{\n    /**\n     * @param {string} message The message this error holds\n     * @param {Range} range The range of this error\n     */\n    constructor(message, range = currRange)\n    {\n        this.message = message;\n        this.range = range;\n    }\n}", "export class RelocEntry\n{\n    /**\n     * \n     * @param {Object} config\n     * @param {number} config.offset\n     * @param {number} config.sizeReduction\n     * @param {import(\"./shuntingYard\").IdentifierValue} config.value\n     * @param {number} config.size\n     * @param {boolean} config.signed\n     * @param {boolean} config.pcRelative\n     * @param {boolean} config.functionAddr\n     */\n    constructor({ offset, sizeReduction, value, size, signed, pcRelative, functionAddr })\n    {\n        this.offset = offset;\n        value = value.flatten();\n        this.addend = value.addend - sizeReduction;\n        if(pcRelative)\n            this.addend += BigInt(offset);\n        this.symbol = value.symbol;\n        this.size = size;\n        this.signed = signed;\n        this.pcRelative = pcRelative;\n        this.functionAddr = functionAddr;\n    }\n}", "/**\r\n * Infer the size (in bits - 8, 16, 32, etc.) of a BigInt number\r\n * @param {BigInt} value the value to check\r\n * @param {boolean} signed if true, assumes two's-complement represents negative numbers\r\n * @returns the bits in the minimum number of bytes needed to represent the number\r\n */\r\nexport function inferSize(value, signed = true)\r\n{\r\n    if(signed)\r\n    {\r\n        if(value < 0n) // Correct for negative values\r\n            value = ~value;\r\n\r\n        return value < 0x80n ? 8 :\r\n                value < 0x8000n ? 16 :\r\n                value < 0x80000000n ? 32 : 64;\r\n    }\r\n    else\r\n    {\r\n        if(value < 0n) // Technically this doesn't make sense, but we'll allow it\r\n            value = -2n * value - 1n;\r\n\r\n        return value < 0x100n ? 8 :\r\n                value < 0x10000n ? 16 :\r\n                value < 0x100000000n ? 32 : 64;\r\n    }\r\n}", "import { currSection } from \"./compiler.js\";\r\nimport { ASMError, currSyntax, Range } from \"./parser.js\";\r\nimport { pseudoSections, Section } from \"./sections.js\";\r\nimport { inferSize } from \"./utils.js\";\r\n\r\nvar totalStatements = 0;\r\n\r\n/**\r\n * @typedef {Object} InstructionRange\r\n * @property {StatementNode} head The last instruction before the range\r\n * @property {StatementNode} prev The last compiled instruction\r\n * @property {StatementNode} tail The first instruction after the range\r\n */\r\n\r\nexport class StatementNode\r\n{\r\n    /** @param {Statement?} statement */\r\n    constructor(statement = null)\r\n    {\r\n        this.statement = statement;\r\n        /** @type {StatementNode?} */\r\n        this.next = null;\r\n    }\r\n\r\n    /**\r\n     * @param {Number} pos\r\n     * @returns {StatementNode?} */\r\n    find(pos)\r\n    {\r\n        if(this.statement && this.statement.range.includes(pos))\r\n            return this;\r\n        return this.next?.find(pos);\r\n    }\r\n\r\n    length()\r\n    {\r\n        let node = this, length = 0;\r\n        while(node)\r\n        {\r\n            if(node.statement)\r\n                length += node.statement.length;\r\n            node = node.next;\r\n        }\r\n        return length;\r\n    }\r\n\r\n    dump()\r\n    {\r\n        let output, i = 0, node = this;\r\n\r\n        // Use the available byte array type\r\n        try { output = Buffer.alloc(this.length()); }\r\n        catch(e) { output = new Uint8Array(this.length()); }\r\n\r\n        while(node)\r\n        {\r\n            if(node.statement)\r\n            {\r\n                output.set(node.statement.bytes.subarray(0, node.statement.length), i);\r\n                i += node.statement.length;\r\n            }\r\n            node = node.next;\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    /** Select the instruction range that is affected by a given range\r\n     * @param {Range} range\r\n     * @param {boolean} update\r\n     * @param {Number} sourceLength\r\n     * @returns {InstructionRange}\r\n     */\r\n    getAffectedArea(range, update = false, sourceLength = 0)\r\n    {\r\n        let node = this;\r\n        let head = this, last = null, tail = null;\r\n        let changeOffset = sourceLength - range.length;\r\n        while(node)\r\n        {\r\n            let instr = node.statement;\r\n            if(instr)\r\n            {\r\n                if(instr.range.end < range.start) // Before the range\r\n                    head = node;\r\n                else if(instr.range.start <= range.end) // Inside the range\r\n                {\r\n                    last = node;\r\n                    if(update)\r\n                    {\r\n                        if(instr.range.end >= range.end)\r\n                            instr.range.length += changeOffset;\r\n                        instr.remove();\r\n                    }\r\n                }\r\n                else // After the range\r\n                {\r\n                    if(tail === null)\r\n                        tail = node;\r\n                    \r\n                    if(update)\r\n                        instr.range.start += changeOffset;\r\n                }\r\n            }\r\n\r\n            node = node.next;\r\n        }\r\n\r\n        if(update)\r\n        {\r\n            // Expand the range a bit so as not to cut off the first and last instructions\r\n            if(last)\r\n            {\r\n                range.start = Math.min(range.start, head.next.statement.range.start);\r\n                range.length = last.statement.range.end - range.start;\r\n            }\r\n            else if(tail)\r\n                range.length = tail.statement.range.start - range.start - 1;\r\n            else\r\n                range.length = sourceLength;\r\n        }\r\n        \r\n        return { head, prev: head, tail };\r\n    }\r\n}\r\n\r\nexport class Statement\r\n{\r\n    /**\r\n     * @param {Object} config\r\n     * @param {Number} config.addr\r\n     * @param {Number} config.maxSize\r\n     * @param {Range} config.range\r\n     * @param {ASMError?} config.error\r\n     * @param {Section} config.section\r\n     * @param {import(\"./parser.js\").Syntax} config.syntax */\r\n    constructor({ addr = 0, maxSize = 0, range = new Range(), error = null, section = currSection, syntax = currSyntax } = {})\r\n    {\r\n        this.id = totalStatements++; // Each Statement gets a unique ID\r\n        \r\n        this.error = error;\r\n        this.range = range;\r\n        this.bytes = new Uint8Array(maxSize);\r\n        this.syntax = syntax;\r\n        this.address = addr;\r\n        this.section = section;\r\n\r\n        this.sectionNode = new StatementNode(this);\r\n\r\n        /* A statement is marked as removed if its initial compilation resulted\r\n        in an unfixable error, or if it was deleted by user input. */\r\n        this.removed = true;\r\n\r\n        this.clear();\r\n    }\r\n\r\n    clear()\r\n    {\r\n        this.length = 0;\r\n        this.relocations = [];\r\n\r\n        /** @type {Number[]} */\r\n        this.lineEnds = [];\r\n    }\r\n\r\n    /** @param {BigInt|Number} byte */\r\n    genByte(byte)\r\n    {\r\n        this.bytes[this.length++] = Number(byte);\r\n    }\r\n\r\n    /**\r\n     * @typedef {Object} ValueConfig\r\n     * @property {number} size\r\n     * @property {boolean} signed\r\n     * @property {boolean} sizeRelative\r\n     * @property {boolean} functionAddr\r\n     * @property {number?} dispMul\r\n     */\r\n\r\n    /**\r\n     * @param {import(\"./shuntingYard.js\").IdentifierValue} value\r\n     * @param {ValueConfig} config\r\n     */\r\n    genValue(value, {\r\n        size,\r\n        signed = false,\r\n        sizeRelative = false,\r\n        functionAddr = false,\r\n        dispMul = null\r\n    } = {})\r\n    {\r\n        let sizeReduction = sizeRelative ? BigInt(this.length + size / 8) : 0n;\r\n        let num = 0n;\r\n        \r\n        if(value.isRelocatable())\r\n        {\r\n            if(size >= 128)\r\n                throw new ASMError(\"Can't do 16 byte relocations\", value.range);\r\n            this.relocations.push({\r\n                offset: this.length,\r\n                sizeReduction,\r\n                value,\r\n                signed: signed && !value.pcRelative && size == 32,\r\n                size,\r\n                pcRelative: value.pcRelative,\r\n                functionAddr: functionAddr && value.section == pseudoSections.UND,\r\n            });\r\n        }\r\n        else\r\n        {\r\n            num = value.addend - sizeReduction;\r\n            if(dispMul !== null)\r\n            {\r\n                let shrunkValue = num / BigInt(dispMul);\r\n                if(num % BigInt(dispMul) == 0 && inferSize(shrunkValue) == 8)\r\n                {\r\n                    num = shrunkValue;\r\n                    size = 8;\r\n                }\r\n                else\r\n                    size = 32;\r\n            }\r\n        }\r\n\r\n        for(const lineEnd of value.lineEnds)\r\n            this.lineEnds.push(this.length + Math.min(lineEnd, size / 8));\r\n\r\n        do\r\n        {\r\n            this.genByte(num & 0xffn);\r\n            num >>= 8n;\r\n        } while(size -= 8);\r\n    }\r\n\r\n    remove()\r\n    {\r\n        this.removed = true;\r\n    }\r\n}", "/**\r\n * Create a bitfield class with accessible names\r\n * @param {string[]} fieldNames names of the fields in the bitfield\r\n * @returns a class\r\n */\r\nexport function createBitfieldClass(fieldNames)\r\n{\r\n    let prototype = {};\r\n\r\n    for(let i = 0; i < fieldNames.length; i++)\r\n    {\r\n        let fieldValue = 1 << i;\r\n        Object.defineProperty(prototype, fieldNames[i], {\r\n            get()\r\n            {\r\n                return (this.bits & fieldValue) != 0;\r\n            },\r\n            set(value)\r\n            {\r\n                if(value)\r\n                    this.bits |= fieldValue;\r\n                else\r\n                    this.bits &= ~fieldValue;\r\n                return value;\r\n            }\r\n        })\r\n    };\r\n\r\n    prototype.add = function(field) {\r\n        this.bits |= field.bits;\r\n    };\r\n\r\n    return class {\r\n        constructor()\r\n        {\r\n            this.bits = 0;\r\n            Object.setPrototypeOf(this, prototype)\r\n        }\r\n    };\r\n}", "import { createBitfieldClass } from \"./bitfield.js\";\r\nimport { ASMError, token, next, ungetToken, currRange, currSyntax, prevRange, setToken } from \"./parser.js\";\r\nimport { Expression, CurrentIP } from \"./shuntingYard.js\";\r\nimport { currBitness } from \"./compiler.js\";\r\n\r\nexport class OperandType\r\n{\r\n    constructor(name, { hasSize = true, isMemory = false, isVector = false } = {})\r\n    {\r\n        this.name = name;\r\n        this.hasSize = hasSize;\r\n        this.isMemory = isMemory;\r\n        this.isVector = isVector;\r\n    }\r\n\r\n    toString()\r\n    {\r\n        return this.name;\r\n    }\r\n}\r\n\r\n// Operand types\r\nexport const OPT = Object.freeze({\r\nREG:    new OperandType(\"General-purpose register\"),  // 8/64-bit - ax, bl, esi, r15, etc.\r\nVEC:    new OperandType(\"Vector register\", { isVector: true }),  // 64/512-bit - %mm0 / %mm7, %xmm0 / %xmm15, %ymm0 / %ymm15, %zmm0 / %zmm15\r\nVMEM:   new OperandType(\"Vector memory\", { isMemory: true, isVector: true }),  // e.g. (%xmm0)\r\nIMM:    new OperandType(\"Immediate value\"),  // e.g. $20\r\nMASK:   new OperandType(\"Mask register\"),  // 64-bit - %k0 / %k7\r\nREL:    new OperandType(\"Relative address\", { isMemory: true }),  // memory that consists of only an address (may be converted to MEM)\r\nMEM:    new OperandType(\"Memory operand\", { isMemory: true }),  // e.g. (%rax)\r\nST:     new OperandType(\"Floating-point stack register\", { hasSize: false }),  // 80-bit - %st(0) / %st(7)\r\nSEG:    new OperandType(\"Segment register\", { hasSize: false }),  // 16-bit - %cs, %ds, %es, %fs, %gs, %ss\r\nIP:     new OperandType(\"Instruction pointer register\", { hasSize: false }), // only used in memory - %eip or %rip\r\nBND:    new OperandType(\"Bound register\", { hasSize: false }), // 128-bit - %bnd0 / %bnd3\r\nCTRL:   new OperandType(\"Control register\", { hasSize: false }), // 64-bit - %cr0, %cr2, %cr3, %cr4 and %cr8\r\nDBG:    new OperandType(\"Debug register\", { hasSize: false })  // 64-bit - %dr0 / %dr7\r\n});\r\n\r\nexport const registers = Object.assign({}, ...[\r\n\"al\",\"cl\",\"dl\",\"bl\",\"ah\",\"ch\",\"dh\",\"bh\",\r\n\"ax\",\"cx\",\"dx\",\"bx\",\"sp\",\"bp\",\"si\",\"di\",\r\n\"eax\",\"ecx\",\"edx\",\"ebx\",\"esp\",\"ebp\",\"esi\",\"edi\",\r\n\"rax\",\"rcx\",\"rdx\",\"rbx\",\"rsp\",\"rbp\",\"rsi\",\"rdi\",\r\n\"es\",\"cs\",\"ss\",\"ds\",\"fs\",\"gs\",\r\n\"st\",\"rip\",\"eip\",\"spl\",\"bpl\",\"sil\",\"dil\"\r\n].map((x, i) => ({[x]: i})));\r\n\r\nexport const suffixes  = {\r\n    b: 8,\r\n    w: 16,\r\n    l: 32,\r\n    q: 64,\r\n    t: 80,\r\n    x: 128,\r\n    y: 256,\r\n    z: 512\r\n};\r\n// FPU instructions have different suffixes\r\nexport const floatSuffixes = {\r\n    s: 32,\r\n    l: 64,\r\n    t: 80\r\n}\r\nexport const floatIntSuffixes = {\r\n    s: 16,\r\n    l: 32,\r\n    q: 64\r\n}\r\nexport const sizeHints = Object.freeze({\r\n    byte: 8,\r\n    word: 16,\r\n    long: 32,\r\n    dword: 32,\r\n    far: 48,\r\n    fword: 48,\r\n    qword: 64,\r\n    tbyte: 80,\r\n    oword: 128,\r\n    xmmword: 128,\r\n    ymmword: 256,\r\n    zmmword: 512\r\n});\r\n\r\n/** @param {string} sizeHint */\r\nexport function isSizeHint(sizeHint)\r\n{\r\n    return sizeHints.hasOwnProperty(sizeHint);\r\n}\r\n\r\nexport function nameRegister(name, size, syntax)\r\n{\r\n    return `${syntax.prefix ? '%' : ''}${size == 32 ? 'e' : 'r'}` + name;\r\n}\r\n\r\nexport const PrefixEnum = createBitfieldClass([\r\n    \"REX\", \"NOREX\", \"LOCK\", \"REPNE\", \"REPE\", \"DATASIZE\", \"ADDRSIZE\",\r\n    \"SEG0\", \"SEG1\", \"SEG2\", \"SEG3\", \"SEG4\", \"SEG5\", \"EVEX\"\r\n]);\r\n\r\nexport var regParsePos;\r\n\r\nexport var regSuffixes = {\r\n    b: 8,\r\n    w: 16,\r\n    d: 32\r\n}\r\n\r\n/** Check if a given string corresponds to a register name (ignoring the '%' prefix).\r\n * @param {string} reg\r\n */\r\nexport function isRegister(reg, bitness = currBitness)\r\n{\r\n    reg = reg.toLowerCase();\r\n    if(registers.hasOwnProperty(reg))\r\n    {\r\n        if(bitness == 64)\r\n            return true;\r\n\r\n        // Filter out registers not available in 32-bit mode\r\n        let regIndex = registers[reg];\r\n        return (\r\n            regIndex < registers.rax ||\r\n            (regIndex >= registers.es && regIndex <= registers.st)\r\n        );\r\n    }\r\n    if(bitness == 64 && reg[0] === 'r')\r\n    {\r\n        reg = reg.slice(1);\r\n        if(parseInt(reg) >= 0 && parseInt(reg) < 16 && (!isNaN(reg) || regSuffixes[reg[reg.length - 1]]))\r\n            return true;\r\n    }\r\n    else\r\n    {\r\n        let max = bitness == 64 ? 32 : 8;\r\n        if(reg.startsWith(\"mm\") || reg.startsWith(\"dr\")) reg = reg.slice(2), max = 8;\r\n        else if(reg.startsWith(\"cr\")) reg = reg.slice(2), max = bitness == 64 ? 9 : 8;\r\n        else if(reg.startsWith(\"xmm\") || reg.startsWith(\"ymm\") || reg.startsWith(\"zmm\")) reg = reg.slice(3);\r\n        else if(reg.startsWith(\"bnd\")) reg = reg.slice(3), max = 4;\r\n        else if(reg[0] == 'k') reg = reg.slice(1), max = 8;\r\n        else return false;\r\n        if(!isNaN(reg) && (reg = parseInt(reg), reg >= 0 && reg < max))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * @typedef {Object} Register\r\n * @property {Number} reg\r\n * @property {OperandType} type\r\n * @property {Number} size\r\n * @property {PrefixEnum} prefs\r\n */\r\n\r\n/** @returns {Register} */\r\nexport function parseRegister(expectedType = null)\r\n{\r\n    let regToken = (currSyntax.prefix ? next() : token).toLowerCase();\r\n    let reg = registers[regToken];\r\n    let size = 0, type = -1, prefs = new PrefixEnum();\r\n    if(reg >= registers.al && reg <= (currBitness == 64 ? registers.rdi : registers.edi))\r\n    {\r\n        type = OPT.REG;\r\n        size = 8 << (reg >> 3);\r\n        if(size == 8 && reg >= registers.ah && reg <= registers.bh)\r\n            prefs.NOREX = true;\r\n        reg &= 7;\r\n    }\r\n    else if(reg >= registers.es && reg <= registers.gs)\r\n    {\r\n        type = OPT.SEG;\r\n        size = 32; // Dunno what the actual size of the seg registers is, but this'll prevent the word prefix\r\n        reg -= registers.es;\r\n    }\r\n    else if(reg == registers.st)\r\n    {\r\n        type = OPT.ST;\r\n        reg = 0;\r\n        if(next() == '(')\r\n        {\r\n            reg = parseInt(next());\r\n            if(isNaN(reg) || reg >= 8 || reg < 0 || next() != ')')\r\n                throw new ASMError(\"Unknown register\");\r\n        }\r\n        else\r\n            ungetToken();\r\n    }\r\n    // RIP-relative addressing is only available in 64-bit mode\r\n    else if(currBitness == 64 && (reg == registers.rip || reg == registers.eip))\r\n    {\r\n        if(expectedType === null || !expectedType.includes(OPT.IP))\r\n            throw new ASMError(`Can't use ${nameRegister('ip', reg == registers.eip ? 32 : 64, currSyntax)} here`);\r\n        type = OPT.IP;\r\n        size = reg == registers.eip ? 32 : 64;\r\n        reg = 0;\r\n    }\r\n    else if(currBitness == 64 && reg >= registers.spl && reg <= registers.dil)\r\n    {\r\n        type = OPT.REG;\r\n        size = 8;\r\n        prefs.REX = true;\r\n        reg -= registers.spl - 4;\r\n    }\r\n    else if(currBitness == 64 && regToken[0] == 'r') // Attempt to parse the register name as a numeric (e.g. r10)\r\n    {\r\n        reg = parseInt(regToken.slice(1));\r\n        if(isNaN(reg) || reg < 0 || reg >= 16)\r\n            throw new ASMError(\"Unknown register\");\r\n        type = OPT.REG;\r\n\r\n        let regLastChar = regToken[regToken.length - 1];\r\n        if(isNaN(regLastChar))\r\n        {\r\n            size = regSuffixes[regLastChar];\r\n            if(!size)\r\n                throw new ASMError(\"Unknown register\");\r\n        }\r\n        else\r\n            size = 64;\r\n    }\r\n    else\r\n    {\r\n        let max = currBitness == 64 ? 32 : 8;\r\n        if(token.startsWith(\"bnd\")) reg = regToken.slice(3), type = OPT.BND, max = 4;\r\n        else if(regToken[0] == 'k') reg = regToken.slice(1), type = OPT.MASK, max = 8, size = NaN;\r\n        else if(regToken.startsWith(\"dr\")) reg = regToken.slice(2), type = OPT.DBG, max = 8;\r\n        else if(regToken.startsWith(\"cr\")) reg = regToken.slice(2), type = OPT.CTRL, max = currBitness == 64 ? 9 : 8;\r\n        else\r\n        {\r\n            type = OPT.VEC;\r\n            if(regToken.startsWith(\"mm\")) reg = regToken.slice(2), size = 64, max = 8;\r\n            else if(regToken.startsWith(\"xmm\")) reg = regToken.slice(3), size = 128;\r\n            else if(regToken.startsWith(\"ymm\")) reg = regToken.slice(3), size = 256;\r\n            else if(regToken.startsWith(\"zmm\")) reg = regToken.slice(3), size = 512;\r\n            else\r\n                throw new ASMError(\"Unknown register\");\r\n        }\r\n\r\n        if(isNaN(reg) || !(reg = parseInt(reg), reg >= 0 && reg < max))\r\n            throw new ASMError(\"Unknown register\");\r\n    }\r\n    \r\n    if(expectedType != null && expectedType.indexOf(type) < 0)\r\n        throw new ASMError(\"Invalid register\");\r\n    \r\n    regParsePos = currRange;\r\n    next();\r\n    return { reg, type, size, prefs };\r\n}\r\n\r\n\r\nexport class Operand\r\n{\r\n    /** @param {Statement} instr */\r\n    constructor(instr, expectRelative = false)\r\n    {\r\n        this.reg = this.reg2 = -1;\r\n        this.shift = 0;\r\n        this.value = null;\r\n        this.type = null;\r\n        this.size = NaN;\r\n        this.prefs = new PrefixEnum();\r\n        this.attemptedSizes = 0;\r\n        this.attemptedUnsignedSizes = 0;\r\n\r\n        this.startPos = currRange;\r\n        let indirect = token == '*';\r\n        if(indirect && !instr.syntax.intel)\r\n            next();\r\n        \r\n        let forceMemory = false;\r\n\r\n        if(instr.syntax.prefix && isRegister(token))\r\n            throw new ASMError(\"Registers must be prefixed with '%'\");\r\n\r\n        if(instr.syntax.prefix ? token == '%' : isRegister(token)) // Register\r\n        {\r\n            const regData = parseRegister();\r\n            this.endPos = regParsePos;\r\n            if(regData.type === OPT.SEG && token == ':')\r\n            {\r\n                this.prefs[`SEG${regData.reg}`] = true;\r\n                forceMemory = true;\r\n                next();\r\n            }\r\n            else\r\n            {\r\n                Object.assign(this, regData);\r\n                return;\r\n            }\r\n        }\r\n        if(instr.syntax.intel)\r\n        {\r\n            this.type = expectRelative ? OPT.REL : OPT.IMM;\r\n            if(token != '[' && !forceMemory)\r\n            {\r\n                let mayBeMem = !expectRelative;\r\n                if(token.toLowerCase() == 'offset')\r\n                {\r\n                    next();\r\n                    this.type = OPT.IMM;\r\n                    mayBeMem = false;\r\n                }\r\n                this.expression = new Expression(instr);\r\n                if(this.expression.hasSymbols && mayBeMem)\r\n                    this.type = OPT.MEM;\r\n            }\r\n\r\n            const hasBracket = token == '[';\r\n\r\n            // Intel syntax\r\n            if(hasBracket || forceMemory) // Memory\r\n            {\r\n                this.type = OPT.MEM;\r\n                if(hasBracket)\r\n                    next();\r\n                \r\n                let secExpr = new Expression(instr, true);\r\n                if(this.expression) // Combining the first and second expressions\r\n                    this.expression.apply('+', secExpr);\r\n                else\r\n                    this.expression = secExpr;\r\n                \r\n                this.ripRelative = this.expression.ripRelative;\r\n                if(this.expression.vecSize)\r\n                {\r\n                    this.size = this.expression.vecSize;\r\n                    this.type = OPT.VMEM;\r\n                }\r\n                \r\n                if(hasBracket)\r\n                {\r\n                    if(token != ']')\r\n                        throw new ASMError(\"Expected ']'\");\r\n                    next();\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // AT&T syntax\r\n            if(token[0] == '$') // Immediate\r\n            {\r\n                if(token.length > 1)\r\n                {\r\n                    setToken(token.slice(1));\r\n                    currRange.start++;\r\n                }\r\n                else\r\n                    next();\r\n                this.expression = new Expression(instr);\r\n                this.type = OPT.IMM;\r\n            }\r\n            else // Address\r\n            {\r\n                this.type = OPT.MEM;\r\n                this.expression = new Expression(instr, true);\r\n                if(this.expression.vecSize)\r\n                {\r\n                    this.size = this.expression.vecSize;\r\n                    this.type = OPT.VMEM;\r\n                }\r\n                if(token != '(')\r\n                {\r\n                    if(!indirect && expectRelative)\r\n                        this.type = OPT.REL;\r\n                }\r\n                else\r\n                {\r\n                    let tempReg;\r\n                    if(instr.syntax.prefix ? next() == '%' : isRegister(next()))\r\n                    {\r\n                        tempReg = parseRegister([OPT.REG, OPT.IP]);\r\n                        this.reg = tempReg.reg;\r\n                    }\r\n                    else if(token == ',')\r\n                    {\r\n                        this.reg = -1;\r\n                        tempReg = { type: -1, size: currBitness };\r\n                    }\r\n                    else\r\n                        throw new ASMError(\"Expected register\");\r\n                    \r\n                    if(tempReg.size == 32 && currBitness == 64)\r\n                        this.prefs.ADDRSIZE = true;\r\n                    else if(tempReg.size != currBitness)\r\n                        throw new ASMError(\"Invalid register size\", regParsePos);\r\n                    if(tempReg.type === OPT.IP)\r\n                        this.ripRelative = true;\r\n                    else if(token == ',')\r\n                    {\r\n                        if(instr.syntax.prefix ? next() != '%' : !isRegister(next()))\r\n                            throw new ASMError(\"Expected register\");\r\n                        tempReg = parseRegister([OPT.REG, OPT.VEC]);\r\n                        this.reg2 = tempReg.reg;\r\n                        if(tempReg.type === OPT.VEC)\r\n                        {\r\n                            this.type = OPT.VMEM; this.size = tempReg.size;\r\n                            if(tempReg.size < 128)\r\n                                throw new ASMError(\"Invalid register size\", regParsePos);\r\n                        }\r\n                        else\r\n                        {\r\n                            if(this.reg2 == 4)\r\n                                throw new ASMError(`Memory index cannot be ${tempReg.size == 64 ? 'R' : 'E'}SP`, regParsePos);\r\n                            if(tempReg.size == 32 && currBitness == 64)\r\n                                this.prefs.ADDRSIZE = true;\r\n                            else if(tempReg.size != currBitness)\r\n                                throw new ASMError(\"Invalid register size\", regParsePos);\r\n                        }\r\n\r\n                        if(token == ',')\r\n                        {\r\n                            this.shift = \"1248\".indexOf(next());\r\n                            if(this.shift < 0)\r\n                                throw new ASMError(\"Scale must be 1, 2, 4, or 8\");\r\n                            next();\r\n                        }\r\n                    }\r\n                    \r\n                    if(token != ')')\r\n                        throw new ASMError(\"Expected ')'\");\r\n                    next();\r\n                }\r\n            }\r\n        }\r\n        if(this.expression)\r\n        {\r\n            if(this.type === OPT.REL)\r\n                this.expression.apply('-', new CurrentIP(instr));\r\n            if(!this.expression.hasSymbols)\r\n                this.evaluate(instr);\r\n        }\r\n        this.endPos = prevRange;\r\n    }\r\n\r\n    sizeAllowed(size, unsigned = false)\r\n    {\r\n        return size >= (unsigned ? this.unsignedSize : this.size) || this.sizeAvailable(size, unsigned);\r\n    }\r\n\r\n    sizeAvailable(size, unsigned = false)\r\n    {\r\n        return !((unsigned ? this.attemptedUnsignedSizes : this.attemptedSizes) & 1 << (size >> 4));\r\n    }\r\n\r\n    recordSizeUse(size, unsigned = false)\r\n    {\r\n        if(unsigned)\r\n            this.attemptedUnsignedSizes |= 1 << (size >> 4);\r\n        else\r\n            this.attemptedSizes |= 1 << (size >> 4);\r\n    }\r\n    \r\n    clearAttemptedSizes()\r\n    {\r\n        this.attemptedSizes = this.attemptedUnsignedSizes = 0;\r\n    }\r\n\r\n    evaluate(instr, intelMemory = false)\r\n    {\r\n        this.value = this.expression.evaluate(instr);\r\n        if(intelMemory)\r\n        {\r\n            this.prefs.ADDRSIZE = false;\r\n            let { regBase = null, regIndex = null, shift = 1 } = this.value.regData ?? {};\r\n            if(regBase)\r\n                this.reg = regBase.reg;\r\n            if(regIndex)\r\n                this.reg2 = regIndex.reg;\r\n            if(currBitness == 64 && (regBase && regBase.size == 32 || regIndex && regIndex.size == 32))\r\n                this.prefs.ADDRSIZE = true;\r\n            this.shift = [1, 2, 4, 8].indexOf(shift);\r\n            if(this.shift < 0)\r\n                throw new ASMError(\"Scale must be 1, 2, 4, or 8\", this.value.range);\r\n\r\n            if(this.ripRelative && regIndex)\r\n                throw new ASMError(`Can't use another register with ${nameRegister('ip', regBase.size, instr.syntax)}`, this.value.range);\r\n        }\r\n\r\n        if((this.reg & 7) == 5)\r\n            this.value.addend = this.value.addend || 0n;\r\n    }\r\n}", "import { isRegister, nameRegister, OPT, parseRegister, regParsePos } from \"./operands.js\";\r\nimport { ASMError, currRange, next, Range, setToken, token, ungetToken } from \"./parser.js\";\r\nimport { referenceSymbol, symbols } from \"./symbols.js\";\r\nimport { Statement } from \"./statement.js\";\r\nimport { pseudoSections } from \"./sections.js\";\r\nimport { inferSize } from \"./utils.js\";\r\n\r\nlet unaryTemps = {\r\n    '+': a=>a,\r\n    '-': a=>-a,\r\n    '~': a=>~a,\r\n    '!': a=>!a,\r\n};\r\n\r\nlet operatorTemps = [\r\n    {\r\n        '*': (a,b)=>a*b,\r\n        '/': (a,b)=>a/(b||1n),\r\n        '%': (a,b)=>a%(b||1n),\r\n        '<<':(a,b)=>a<<b,\r\n        '>>':(a,b)=>a>>b,\r\n    },\r\n    {\r\n        '|': (a,b)=>a|b,\r\n        '&': (a,b)=>a&b,\r\n        '^': (a,b)=>a^b,\r\n        '!': (a,b)=>a|~b,\r\n    },\r\n    {\r\n        '+': (a,b)=>a+b,\r\n        '-': (a,b)=>a-b,\r\n    },\r\n    {\r\n        '==':(a,b)=>a==b?-1n:0n,\r\n        '<>':(a,b)=>a!=b?-1n:0n,\r\n        '!=':(a,b)=>a!=b?-1n:0n,\r\n        '<': (a,b)=>a<b?-1n:0n,\r\n        '>': (a,b)=>a>b?-1n:0n,\r\n        '>=':(a,b)=>a>=b?-1n:0n,\r\n        '<=':(a,b)=>a<=b?-1n:0n,\r\n    },\r\n    {   '&&':(a,b)=>a&&b?1n:0n },\r\n    {   '||':(a,b)=>a||b?1n:0n },\r\n];\r\n\r\n/**\r\n * @typedef {Object} Operator\r\n * @property {string} name\r\n * @property {Function} func\r\n * @property {Range} range\r\n * @property {Number} prec */\r\n\r\n/** @type {Object.<string, Operator>} */\r\nvar operators = {};\r\n/** @type {Object.<string, Operator>} */\r\nvar unaries = {};\r\n\r\nfor(let i = 0; i < operatorTemps.length; i++)\r\n    for(const op of Object.keys(operatorTemps[i]))\r\n        operators[op] = { func: operatorTemps[i][op], prec: i };\r\nfor(const op of Object.keys(unaryTemps))\r\n    unaries[op] = { func: unaryTemps[op] };\r\n\r\nconst stringEscapeSeqs = {\r\n    'a': 0x07,\r\n    'b': 0x08,\r\n    'e': 0x1B,\r\n    'f': 0x0C,\r\n    'n': 0x0A,\r\n    'r': 0x0D,\r\n    't': 0x09,\r\n    'v': 0x0B,\r\n}\r\n\r\n\r\nconst encoder = new TextEncoder();\r\nexport function readString(string)\r\n{\r\n    if(string.length < 2 || string[string.length - 1] != string[0])\r\n        throw new ASMError(\"Incomplete string\");\r\n    \r\n    const lineEnds = [];\r\n\r\n    let output = [];\r\n    let matches = string.slice(1, -1).match(/(\\\\(?:x[0-9a-f]{1,2}|[0-7]{1,3}|u[0-9a-f]{1,8}|(.|\\n)?))|\\n|[^\\\\\\n]+/ig);\r\n    if(matches)\r\n        for(let x of matches)\r\n        {\r\n            if(x[0] == '\\\\')\r\n            {\r\n                x = x.slice(1);\r\n                if(x == '')\r\n                    throw new ASMError(\"Incomplete string\");\r\n\r\n                if(x.match(/x[0-9a-f]{1,2}/i))\r\n                    output.push(parseInt(x.slice(1), 16));\r\n                else if(x.match(/u[0-9a-f]{1,8}/i))\r\n                    output.push(...encoder.encode(String.fromCodePoint(parseInt(x.slice(1), 16))));\r\n                else if(x.match(/[0-7]{1,3}/))\r\n                    output.push(parseInt(x, 8) & 255);\r\n                else if(stringEscapeSeqs.hasOwnProperty(x))\r\n                    output.push(stringEscapeSeqs[x]);\r\n                else if(x != '\\n') // Line breaks preceded by a backslash should not be added\r\n                    output.push(...encoder.encode(x));\r\n            }\r\n            else\r\n                output.push(...encoder.encode(x));\r\n\r\n            if(x == '\\n')\r\n                lineEnds.push(output.length);\r\n        }\r\n\r\n    return { bytes: new Uint8Array(output), lineEnds };\r\n}\r\n\r\n/** Get the type of an identifier (returns null if the string isn't a valid identifier).\r\n * @param {string} id\r\n * @param {boolean} intel\r\n * @returns {'symbol' | 'number'}\r\n */\r\nexport function scanIdentifier(id, intel)\r\n{\r\n    if(id[0].match(/[a-z_.$]/i))\r\n        return 'symbol';\r\n    if(id[0].match(/[^0-9]/))\r\n        return null;\r\n    if(id.match(/^([0-9]+|0x[0-9a-f]+|0o[0-7]+|0b[01]+)$/i) || intel && id.match(/^([0-9][0-9a-f]*)h$/i))\r\n        return 'number';\r\n    return null;\r\n}\r\n\r\n\r\nfunction parseIdentifier(instr)\r\n{\r\n    let value = 0n, startRange = currRange;\r\n    \r\n    try\r\n    {\r\n        if(token === '\\n')\r\n            throw new ASMError(\"Expected value, got none\");\r\n        if(token[0] === \"'\")\r\n        {\r\n            let { bytes, lineEnds } = readString(token), i = bytes.length;\r\n            \r\n            while(i--)\r\n            {\r\n                value <<= 8n;\r\n                value += BigInt(bytes[i]);\r\n            }\r\n\r\n            next();\r\n            return new Identifier(instr, value, startRange, lineEnds);\r\n        }\r\n        if(instr.syntax.prefix ? token == '%' : isRegister(token)) // Register\r\n            return new RegisterIdentifier(instr, parseRegister([OPT.REG, OPT.IP, OPT.VEC]), regParsePos);\r\n        \r\n        const idType = scanIdentifier(token, instr.syntax.intel);\r\n        if(idType == 'symbol') // Symbol\r\n        {\r\n            const name = token;\r\n            next();\r\n            return new SymbolIdentifier(instr, name, startRange);\r\n        }\r\n\r\n        if(idType === null)\r\n            throw new ASMError(\"Invalid number\");\r\n\r\n        let mainToken = token;\r\n        if(token[token.length - 1].toLowerCase() == 'h')\r\n            mainToken = '0x' + token.slice(0, -1);\r\n        value = BigInt(mainToken);\r\n        next();\r\n        return new Identifier(instr, value, startRange);\r\n    }\r\n    catch(e)\r\n    {\r\n        if(e.range === undefined)\r\n            throw new ASMError(e);\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * @typedef {Object} RegisterData\r\n * @property {Number} shift\r\n * @property {import('./operands.js').Register?} regBase\r\n * @property {import('./operands.js').Register?} regIndex\r\n */\r\n\r\nexport class IdentifierValue\r\n{\r\n    /**\r\n     * @param {Object} config\r\n     * @param {BigInt} config.addend \r\n     * @property {import('./symbols.js').Symbol} config.symbol\r\n     * @property {Section} config.section\r\n     * @property {Range} config.range\r\n     * @property {RegData} config.regData\r\n     * @property {Number[]} lineEnds */\r\n    constructor({ addend = null, symbol = null, section = pseudoSections.UND, range, regData = null, pcRelative = false, lineEnds = [] } = {})\r\n    {\r\n        this.addend = addend;\r\n        this.symbol = symbol;\r\n        this.section = section;\r\n        this.range = range;\r\n        this.regData = regData;\r\n        this.pcRelative = pcRelative;\r\n        this.lineEnds = lineEnds;\r\n    }\r\n\r\n    isRelocatable()\r\n    {\r\n        return this.symbol && this.section != pseudoSections.ABS || this.pcRelative;\r\n    }\r\n\r\n    flatten()\r\n    {\r\n        let val = this, addend = this.addend;\r\n        while(val.symbol &&\r\n            (val.section == pseudoSections.ABS || val.symbol.value.symbol && !val.symbol.bind)\r\n            && val.symbol.value !== val)\r\n        {\r\n            val = val.symbol.value;\r\n            addend += val.addend;\r\n        }\r\n        return new IdentifierValue({\r\n            ...val,\r\n            addend\r\n        });\r\n    }\r\n\r\n    absoluteValue()\r\n    {\r\n        let val = this, total = this.addend;\r\n        let passed = new Set([val]);\r\n        while(val.symbol && !passed.has(val.symbol.value))\r\n        {\r\n            val = val.symbol.value;\r\n            total += val.addend;\r\n            passed.add(val);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * @param {Statement} instr\r\n     * @param {IdentifierValue} op1\r\n     * @param {string} func\r\n     * @param {IdentifierValue} op2\r\n     */\r\n     apply(instr, func, op, allowPCRelative = true)\r\n     {\r\n        this.range = this.range.until(op.range);\r\n        if(this.section == pseudoSections.ABS && op.section == pseudoSections.ABS)\r\n            ;\r\n        else if(func == '+' && this.section == pseudoSections.ABS && !this.pcRelative)\r\n        {\r\n            this.section = op.section;\r\n            this.symbol = op.symbol;\r\n        }\r\n        else if((func == '+' || func == '-') && op.section == pseudoSections.ABS)\r\n            ;\r\n        else if(this.pcRelative || op.pcRelative)\r\n            throw new ASMError(\"Bad operands\", this.range);\r\n        else if(func == '-' && this.section == op.section &&\r\n            (this.section != pseudoSections.UND && this.section != pseudoSections.COM || this.symbol == op.symbol))\r\n        {\r\n            if(this.symbol)\r\n                this.addend = this.absoluteValue();\r\n            if(op.symbol)\r\n                op.addend = op.absoluteValue();\r\n            this.section = op.section = pseudoSections.ABS;\r\n            this.symbol = op.symbol = null;\r\n        }\r\n        else if(func == '-' && allowPCRelative && op.section == instr.section)\r\n            this.pcRelative = true;\r\n        else\r\n            throw new ASMError(\"Bad operands\", this.range);\r\n        \r\n        if(this.regData || op.regData)\r\n        {\r\n            if(func != '+' && func != '-' && func != '*' ||\r\n                func == '-' && op.regData)\r\n                throw new ASMError(\"Bad operands\", this.range);\r\n            \r\n            let regOp = this.regData ? this : op;\r\n            let nonRegOp = this.regData ? op : this;\r\n\r\n            if(!this.regData)\r\n                this.regData = op.regData;\r\n            else if(op.regData) // Both operands are registers\r\n            {\r\n                if(func == '*')\r\n                    throw new ASMError(\"Bad operands\", this.range);\r\n                if(this.regData.regIndex && op.regData.regIndex)\r\n                    throw new ASMError(\"Can't have multiple index registers\", this.range);\r\n                if([this.regData, op.regData].some(data => data.regBase && data.regIndex))\r\n                    throw new ASMError(\"Too many registers\", this.range);\r\n                \r\n                if(this.regData.regBase && op.regData.regBase)\r\n                {\r\n                    this.regData.regIndex = [this.regData.regBase, op.regData.regBase].find(reg => reg.reg != 4);\r\n                    if(this.regData.regIndex === undefined)\r\n                        throw new ASMError(`Can't have both registers be ${instr.syntax.prefix ? '%' : ''}rsp`, this.range);\r\n                    if(this.regData.regIndex == this.regData.regBase)\r\n                        this.regData.regBase = op.regData.regBase;\r\n                }\r\n                else if(op.regData.regIndex)\r\n                {\r\n                    this.regData.regIndex = op.regData.regIndex;\r\n                    this.regData.shift = op.regData.shift;\r\n                }\r\n                else\r\n                    this.regData.regBase = op.regData.regBase;\r\n            }\r\n\r\n            if(func == '*')\r\n            {\r\n                if(nonRegOp.section != pseudoSections.ABS)\r\n                    throw new ASMError(\"Scale must be absolute\", nonRegOp.range);\r\n                if(regOp.regData.regIndex && regOp.regData.regBase)\r\n                    throw new ASMError(\"Can't scale both base and index registers\", this.range);\r\n                if(regOp.regData.regBase)\r\n                {\r\n                    const scaled = regOp.regData.regBase;\r\n                    if(scaled.reg == 4)\r\n                        throw new ASMError(`Can't scale ${nameRegister('sp', scaled.size, instr.syntax)}`, this.range);\r\n                    if(scaled.type === OPT.IP)\r\n                        throw new ASMError(`Can't scale ${nameRegister('ip', scaled.size, instr.syntax)}`, this.range);\r\n                    this.regData.regIndex = scaled;\r\n                    this.regData.regBase = null;\r\n                }\r\n                this.regData.shift *= Number(nonRegOp.addend);\r\n                this.addend = regOp.addend !== null ? nonRegOp.addend * regOp.addend : null;\r\n            }\r\n            else if(this.addend !== null || op.addend !== null)\r\n                this.addend = operators[func].func(this.addend ?? 0n, op.addend ?? 0n);\r\n        }\r\n        else\r\n            this.addend = operators[func].func(this.addend, op.addend);\r\n        this.pcRelative = this.pcRelative || op.pcRelative;\r\n        this.lineEnds = [...this.lineEnds, ...op.lineEnds].sort((a, b) => a - b);\r\n    }\r\n\r\n    /** Infer the size of this value\r\n     * @param {boolean} signed Whether to treat this value as signed or not */\r\n    inferSize(signed = true)\r\n    {\r\n        return inferSize(this.addend, signed);\r\n    }\r\n}\r\n\r\nclass Identifier\r\n{\r\n    /**\r\n     * @param {Statement} instr\r\n     * @param {Number} value\r\n     * @param {Range} range\r\n     * @param {Number[]} lineEnds */\r\n    constructor(instr, value, range, lineEnds = [])\r\n    {\r\n        this.value = value;\r\n        this.range = range;\r\n        this.lineEnds = lineEnds;\r\n    }\r\n\r\n    /**\r\n     * @param {Statement} instr\r\n     * @returns {IdentifierValue} */\r\n    getValue(instr)\r\n    {\r\n        return new IdentifierValue({\r\n            addend: this.value,\r\n            section: pseudoSections.ABS,\r\n            range: this.range,\r\n            lineEnds: this.lineEnds\r\n        });\r\n    }\r\n}\r\n\r\nclass SymbolIdentifier extends Identifier\r\n{\r\n    /**\r\n     * @param {Statement} instr\r\n     * @param {string} name\r\n     * @param {Range} range */\r\n    constructor(instr, name, range)\r\n    {\r\n        super(instr, 0, range);\r\n        this.name = name;\r\n        this.isIP = name == (instr.syntax.intel ? '$' : '.');\r\n        if(this.isIP)\r\n            instr.ipRelative = true;\r\n    }\r\n\r\n    /**\r\n     * @param {Statement} instr\r\n     * @returns {IdentifierValue} */\r\n    getValue(instr)\r\n    {\r\n        if(this.isIP)\r\n            return new IdentifierValue({\r\n                addend: BigInt(instr.address),\r\n                symbol: (instr.section.head?.statement ?? instr).symbol,\r\n                section: instr.section,\r\n                range: this.range\r\n            });\r\n        const symbol = symbols.get(this.name);\r\n        if(symbol.statement && !symbol.statement.error)\r\n        {\r\n            if(instr.symbol && checkSymbolRecursion(symbol))\r\n                throw new ASMError(`Recursive definition`, this.range);\r\n            let isAbs = symbol.value.section == pseudoSections.ABS;\r\n            return new IdentifierValue({\r\n                addend: isAbs ? symbol.value.addend : 0n,\r\n                symbol: isAbs ? null : symbol,\r\n                section: symbol.value.section,\r\n                range: this.range\r\n            });\r\n        }\r\n        return new IdentifierValue({\r\n            addend: 0n,\r\n            symbol,\r\n            range: this.range\r\n        });\r\n    }\r\n}\r\n\r\nclass RegisterIdentifier extends Identifier\r\n{\r\n    /**\r\n     * @param {Statement} instr\r\n     * @param {import(\"./operands.js\").Register} register\r\n     * @param {Range} range */\r\n    constructor(instr, register, range)\r\n    {\r\n        super(instr, 0, range);\r\n        this.register = register;\r\n    }\r\n\r\n    getValue()\r\n    {\r\n        return new IdentifierValue({\r\n            section: pseudoSections.ABS,\r\n            range: this.range,\r\n            regData: this.register.type === OPT.VEC \r\n            ?\r\n                {\r\n                    shift: 1,\r\n                    regBase: null,\r\n                    regIndex: this.register\r\n                }\r\n            :\r\n                {\r\n                    shift: 1,\r\n                    regBase: this.register,\r\n                    regIndex: null\r\n                }\r\n        });\r\n    }\r\n}\r\n\r\nexport class Expression\r\n{\r\n    /** @param {Statement} instr */\r\n    constructor(instr, expectMemory = false, uses = null)\r\n    {\r\n        this.hasSymbols = false;\r\n        this.vecSize = 0;\r\n        this.ripRelative = false;\r\n\r\n        /** @type {(Identifier|RegisterIdentifier|Operator)[]} */\r\n        this.stack = [];\r\n\r\n        /** @type {Operator[]}*/\r\n        let opStack = [];\r\n        let lastOp, lastWasNum = false;\r\n\r\n        while(token != ',' && token != '\\n' && token != ';')\r\n        {\r\n            if(!lastWasNum && unaries.hasOwnProperty(token)) // Unary operator\r\n            {\r\n                opStack.push({range: currRange, func: token, prec: -1, unary: true });\r\n                next();\r\n            }\r\n            else if(operators.hasOwnProperty(token)) // Operator\r\n            {\r\n                if(!lastWasNum)\r\n                {\r\n                    if(expectMemory && instr.syntax.prefix && token == '%')\r\n                    {\r\n                        // If expecting memory e.g. (%rax) the '%' goes in here\r\n                        if(instr.syntax.intel)\r\n                        {\r\n                            lastWasNum = true;\r\n                            this.stack.push(parseIdentifier(instr));\r\n                            continue;\r\n                        }\r\n                        if(opStack.length > 0 && opStack[opStack.length - 1].bracket)\r\n                        {\r\n                            ungetToken();\r\n                            setToken('(');\r\n                            return;\r\n                        }\r\n                    }\r\n                    \r\n                    throw new ASMError(\"Missing left operand\");\r\n                }\r\n\r\n                const op = { range: currRange, func: token, prec: operators[token].prec, unary: false };\r\n                next();\r\n\r\n                lastWasNum = false;\r\n\r\n                while(lastOp = opStack[opStack.length - 1], lastOp && lastOp.prec <= op.prec && !lastOp.bracket)\r\n                    this.stack.push(opStack.pop());\r\n                opStack.push(op);\r\n            }\r\n            else if(unaries.hasOwnProperty(token))\r\n                throw new ASMError(\"Unary operator can't be used here\");\r\n            else if(token == '(')\r\n            {\r\n                if(lastWasNum)\r\n                {\r\n                    if(expectMemory)\r\n                        break;\r\n                    throw new ASMError(\"Unexpected parenthesis\");\r\n                }\r\n                opStack.push({ range: currRange, bracket: true });\r\n                next();\r\n            }\r\n            else if(token == ')')\r\n            {\r\n                if(!lastWasNum)\r\n                    throw new ASMError(\"Missing right operand\", opStack.length ? opStack[opStack.length - 1].range : currRange);\r\n                while(lastOp = opStack[opStack.length - 1], lastOp && !lastOp.bracket)\r\n                    this.stack.push(opStack.pop());\r\n                if(!lastOp || !lastOp.bracket)\r\n                    throw new ASMError(\"Mismatched parentheses\");\r\n                opStack.pop();\r\n                lastWasNum = true;\r\n                next();\r\n            }\r\n            else if(instr.syntax.intel && (token == '[' || token == ']'))\r\n            {\r\n                if(!lastWasNum)\r\n                    throw new ASMError(\"Missing right operand\", opStack.length ? opStack[opStack.length - 1].range : currRange);\r\n                break;\r\n            }\r\n            else // Identifier\r\n            {\r\n                if(lastWasNum)\r\n                    throw new ASMError(\"Unexpected value\");\r\n                lastWasNum = true;\r\n\r\n                if(!instr.syntax.prefix && isRegister(token))\r\n                {\r\n                    if(!expectMemory)\r\n                        throw new ASMError(\"Can't use registers in an expression\");\r\n                    if(!instr.syntax.intel && opStack.length > 0 && opStack[opStack.length - 1].bracket)\r\n                        break;\r\n                }\r\n                this.stack.push(parseIdentifier(instr));\r\n            }\r\n        }\r\n\r\n        if(this.stack.length == 0)\r\n        {\r\n            if(expectMemory)\r\n            {\r\n                ungetToken();\r\n                setToken('(');\r\n                return;\r\n            }\r\n            else\r\n                throw new ASMError(\"Expected expression\");\r\n        }\r\n\r\n        if(!lastWasNum)\r\n            throw new ASMError(\"Missing right operand\", opStack.length ? opStack[opStack.length - 1].range : currRange);\r\n\r\n        while(opStack[0])\r\n        {\r\n            if(opStack[opStack.length - 1].bracket)\r\n                throw new ASMError(\"Mismatched parentheses\", opStack[opStack.length - 1].range);\r\n            this.stack.push(opStack.pop());\r\n        }\r\n\r\n        for(const id of this.stack)\r\n        {\r\n            if(id.register && id.register.type === OPT.VEC)\r\n                this.vecSize = id.register.size;\r\n            else if(id.register && id.register.type === OPT.IP)\r\n                this.ripRelative = true;\r\n            else if(id.name)\r\n            {\r\n                if(!id.isIP)\r\n                {\r\n                    const symbol = referenceSymbol(instr, id.name);\r\n                    if(uses !== null)\r\n                        uses.push(symbol);\r\n                }\r\n                this.hasSymbols = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {Statement} instr\r\n     * @param {boolean} allowPCRelative\r\n     * @param {boolean} expectAbsolute\r\n     * @returns {IdentifierValue} */\r\n    evaluate(instr, allowPCRelative = true, expectAbsolute = false)\r\n    {\r\n        if(this.stack.length == 0)\r\n            return new IdentifierValue({ section: pseudoSections.ABS });\r\n        \r\n        /** @type {IdentifierValue[]} */\r\n        let stack = [], len = 0;\r\n        for(const op of this.stack)\r\n        {\r\n            const func = op.func;\r\n            if(func)\r\n            {\r\n                if(op.unary)\r\n                {\r\n                    if(func == '+')\r\n                        continue;\r\n                    const val = stack[len - 1], minusRelative = val.section == instr.section && func == '-';\r\n                    if(val.regData || val.section != pseudoSections.ABS && !minusRelative || minusRelative && !allowPCRelative)\r\n                        throw new ASMError(\"Bad operand\", val.range);\r\n                    if(minusRelative)\r\n                        val.pcRelative = true;\r\n                    val.addend = unaries[func].func(val.addend);\r\n                }\r\n                else\r\n                {\r\n                    stack[len - 2].apply(instr, func, stack.pop(), allowPCRelative);\r\n                    len--;\r\n                }\r\n            }\r\n            else\r\n                stack[len++] = op.getValue(instr);\r\n        }\r\n        if(stack.length > 1)\r\n            throw new ASMError(\"Invalid expression\", stack[0].range);\r\n        \r\n        if(expectAbsolute)\r\n            if(stack[0].section != pseudoSections.ABS)\r\n                throw new ASMError(\"Expected absolute expression\", stack[0].range);\r\n        return stack[0];\r\n    }\r\n\r\n    /**\r\n     * @param {string} func\r\n     * @param {Expression} expr */\r\n    apply(func, expr = null)\r\n    {\r\n        if(expr === null)\r\n            this.stack.push({ func, unary: true });\r\n        else if(expr.stack.length > 0)\r\n        {\r\n            this.stack.push(...expr.stack, { func, unary: false });\r\n            this.hasSymbols = this.hasSymbols || expr.hasSymbols;\r\n            this.vecSize = this.vecSize || expr.vecSize;\r\n            this.ripRelative = this.ripRelative || expr.ripRelative;\r\n        }\r\n    }\r\n}\r\n\r\nexport function CurrentIP(instr)\r\n{\r\n    this.hasSymbols = true;\r\n    this.pcRelative = false;\r\n    this.stack = [new SymbolIdentifier(instr, instr.syntax.intel ? '$' : '.', currRange)];\r\n}\r\nCurrentIP.prototype = Object.create(Expression.prototype);\r\n\r\n/** Check if a symbol's definition contains a recursion\r\n * @param {import(\"./symbols.js\").Symbol} symbol The checked symbol\r\n * @param {Set.<import(\"./symbols.js\").Symbol>} passed The symbols that have been passed\r\n * @returns {boolean}\r\n */\r\nfunction checkSymbolRecursion(symbol, passed = new Set())\r\n{\r\n    if(passed.has(symbol))\r\n        return true;\r\n\r\n    passed.add(symbol);\r\n    for(const use of symbol.uses)\r\n        if(checkSymbolRecursion(use, passed))\r\n            return true;\r\n\r\n    passed.delete(symbol);\r\n    return false;\r\n}", "import { Expression, CurrentIP, IdentifierValue } from \"./shuntingYard.js\";\nimport { ASMError, next, token } from \"./parser.js\";\nimport { Statement, StatementNode } from \"./statement.js\";\nimport { pseudoSections } from \"./sections.js\";\nimport { SYM_BINDS, SYM_TYPES } from \"./directives.js\";\n\n/** @type {StatementNode[]} */\nexport var recompQueue = [];\n\n/**\n * @typedef {Object} Symbol\n * @property {SymbolDefinition?} statement The statement defining this symbol, if it exists\n * @property {string} name The symbol's name\n * @property {Statement[]} references List of instructions that reference this symbol\n * @property {Statement[]} definitions List of instructions that define or give attributes to this symbol\n * @property {Symbol[]} uses List of symbols used in this symbol's definition\n * @property {number?} type The type field of the symbol in the ELF file\n * @property {number?} bind The bind field of the symbol in the ELF file\n * @property {number?} size The size field of the symbol in the ELF file\n * @property {number?} visibility The visibility field of the symbol in the ELF file\n * @property {import('./shuntingYard.js').IdentifierValue} value The symbol's value\n */\n function makeSymbol({ name, type = undefined, bind = undefined, uses = [], references = [], definitions = [] } = {})\n {\n     return {\n        statement: null,\n        name,\n        references,\n        definitions,\n        uses,\n        value: new IdentifierValue({ addend: 0n }),\n        type,\n        bind\n     };\n }\n\n/** @type {Map<string, Symbol>} */\nexport var symbols = new Map();\n/** @type {string[]} */\nexport var fileSymbols = [];\n\nexport function loadSymbols(table, fileArr)\n{\n    symbols = table;\n    fileSymbols = fileArr;\n}\n\n/** @param {Statement} instr */\nexport function queueRecomp(instr)\n{\n    if(!instr.wantsRecomp)\n        recompQueue.push(instr.sectionNode);\n    instr.wantsRecomp = true;\n}\n\nexport class SymbolDefinition extends Statement\n{\n    /** @type {Symbol} */\n    symbol;\n    constructor({ name, opcodeRange = null, isLabel = false, compile = true, type = 0, bind = 0, ...config })\n    {\n        if(opcodeRange === null)\n            opcodeRange = config.range;\n        super(config);\n        let uses = [];\n        if(isLabel)\n            this.expression = new CurrentIP(this);\n        else\n        {\n            if(compile)\n            {\n                next();\n                this.expression = new Expression(this, false, uses);\n            }\n        }\n\n        // By now, the expression has been correctly parsed, so the instruction is not removed\n        this.removed = false;\n\n        if(symbols.has(name))\n        {\n            this.symbol = symbols.get(name);\n            this.symbol.definitions.push(this);\n            if(this.symbol.statement)\n            {\n                this.error = new ASMError(`This ${isLabel ? 'label' : 'symbol'} already exists`, opcodeRange);\n                this.duplicate = true;\n                return;\n            }\n            this.symbol.uses = uses;\n            this.duplicate = false;\n        }\n        else\n            symbols.set(name, this.symbol = makeSymbol({ name, type, bind, uses, definitions: [this] }));\n\n        if(compile)\n        {\n            this.compile();\n            for(const ref of this.symbol.references)\n                if(!ref.removed)\n                    queueRecomp(ref);\n        }\n    }\n\n    // Re-evaluate the symbol. Return true if references to the symbol should be recompiled\n    compile()\n    {\n        let originError = this.error;\n        let originValue = this.symbol.value;\n        let prevAbs = this.prevAbs;\n        this.error = null;\n\n        let value = undefined;\n        try\n        {\n            value = this.symbol.value = this.expression.evaluate(this, false);\n            this.symbol.statement = this;\n            this.prevAbs = value.absoluteValue();\n        }\n        catch(e)\n        {\n            this.error = e;\n        }\n        return !(originError && this.error) && (!value || originValue.addend !== value.addend\n            || originValue.section !== value.section || prevAbs !== this.prevAbs);\n    }\n\n    recompile()\n    {\n        if(this.duplicate && this.symbol.statement)\n            return;\n        this.duplicate = false;\n        if(this.compile())\n        {\n            this.symbol.statement = this;\n            for(const ref of this.symbol.references)\n                queueRecomp(ref);\n        }\n    }\n\n    remove()\n    {\n        if(!this.duplicate)\n        {\n            let refs = this.symbol.references;\n            if(refs.length > 0)\n            {\n                this.symbol.statement = null;\n                this.symbol.uses = [];\n                \n                // Find a new definition for this symbol, if any exist\n                let newDef = this.symbol.definitions.find(def => def.duplicate);\n                if(newDef)\n                    newDef.recompile();\n                else\n                    for(const instr of this.symbol.references)\n                        queueRecomp(instr);\n            }\n            else\n                symbols.delete(this.symbol.name);\n        }\n        super.remove();\n    }\n}\n\nfunction getAlignment(x)\n{\n    return x <= 1n  ? 1n :\n        x <= 2n ? 2n :\n        x <= 4n ? 4n :\n        x <= 8n ? 8n : 16n;\n}\n\nexport class CommSymbol extends SymbolDefinition\n{\n    constructor({ name, opcodeRange = null, ...config })\n    {\n        super({ ...config, compile: false, bind: SYM_BINDS.global, type: SYM_TYPES.object, name: token });\n        next();\n        if(token != ',')\n            throw new ASMError(\"Expected ','\");\n        next();\n        this.sizeExpr = new Expression(this);\n        this.alignExpr = null;\n\n        if(token == ',')\n        {\n            next();\n            this.alignExpr = new Expression(this);\n        }\n        this.removed = true;\n        this.compile();\n        for(const ref of this.symbol.references)\n            if(!ref.removed)\n                queueRecomp(ref);\n    }\n\n    compile()\n    {\n        let prevErr = this.error;\n        this.error = null;\n        try\n        {\n            const sizeVal = this.sizeExpr.evaluate(this, false, true);\n            if(sizeVal.addend < 0n)\n                throw new ASMError(\"Size cannot be negative\", sizeVal.range);\n            this.symbol.size = sizeVal.addend;\n            \n            if(this.alignExpr)\n                this.symbol.value = this.alignExpr.evaluate(this, false, true);\n            else\n                this.symbol.value = new IdentifierValue({ addend: getAlignment(this.symbol.size) });\n            this.symbol.value.section = pseudoSections.COM;\n\n            this.removed = false;\n            return prevErr !== null;\n        }\n        catch(e)\n        {\n            this.error = e;\n            return prevErr === null;\n        }\n    }\n}\n\nexport function referenceSymbol(instr, name, defining = false)\n{\n    let symbol;\n    if(symbols.has(name))\n    {\n        symbol = symbols.get(name);\n        symbol.references.push(instr);\n        if(defining)\n            symbol.definitions.push(instr);\n    }\n    else\n        symbols.set(name, symbol = makeSymbol({ name, references: [instr], definitions: defining ? [instr] : [] }));\n    return symbol;\n}", "import { Range } from \"./parser.js\";\nimport { RelocEntry } from \"./relocations.js\";\nimport { StatementNode } from \"./statement.js\";\nimport { SymbolDefinition } from \"./symbols.js\";\n\n/** @type {Section[]} */\nexport var sections = [];\n\n/**\n * @param {Section[]} table\n * @param {Range} range */\nexport function loadSections(table, range)\n{\n    sections = table;\n    for(const section of table)\n        section.cursor = section.head.getAffectedArea(range);\n}\n\nexport const pseudoSections = {\n    ABS: { name: '*ABS*', index: 0xfff1 },\n    UND: { name: '*UND*', index: 0 },\n    COM: { name: '*COM*', index: 0xfff2 }\n};\n\nexport const sectionFlags = {\n    a: 2,         // SHF_ALLOC\n    e: 0x8000000, // SHF_EXCLUDE\n    o: 0x40,      // SHF_INFO_LINK\n    w: 1,         // SHF_WRITE\n    x: 4,         // SHF_EXECINSTR\n    M: 0x10,      // SHF_MERGE\n    S: 0x20,      // SHF_STRINGS\n    G: 0x200,     // SHF_GROUP\n    T: 0x400,     // SHF_TLS\n};\n\nexport const sectionTypes = {\n    'progbits': 0x1,\n    'nobits': 0x8,\n    'note': 0x7,\n    'init_array': 0xE,\n    'fini_array': 0xF,\n    'preinit_array': 0x10\n}\n\nexport const STT_SECTION = 3, STT_FILE = 4;\nconst SHT_DYNSYM = 0xB, SHT_DYNAMIC = 0x6;\n\nexport class Section\n{\n    /** @param {string} name */\n    constructor(name)\n    {\n        this.name = name;\n\n        /** @type {import('./statement.js').InstructionRange} */\n        this.cursor = null;\n\n        this.persistent = name == '.text' || name == '.data' || name == '.bss';\n\n        this.head = new StatementNode(new SymbolDefinition({ addr: 0, name, isLabel: true, type: STT_SECTION, section: this }));\n        this.entryPoints = [];\n\n        this.cursor = { head: this.head, prev: this.head };\n\n        switch(name)\n        {\n            case '.text':\n            case '.init':\n            case '.fini':\n                this.flags = sectionFlags.a | sectionFlags.x; break;\n            case '.rodata':\n            case '.dynsym':\n            case '.dynamic':\n                this.flags = sectionFlags.a; break;\n            case '.data':\n            case '.bss':\n            case '.preinit_array':\n            case '.init_array':\n            case '.fini_array':\n                this.flags = sectionFlags.a | sectionFlags.w; break;\n            default: this.flags = 0;\n        }\n\n        switch(name)\n        {\n            case '.notes':         this.type = sectionTypes.note; break;\n            case '.bss':           this.type = sectionTypes.nobits; break;\n            case '.preinit_array': this.type = sectionTypes.preinit_array; break;\n            case '.init_array':    this.type = sectionTypes.init_array; break;\n            case '.fini_array':    this.type = sectionTypes.fini_array; break;\n            case '.dynsym':        this.type = SHT_DYNSYM; break;\n            case '.dynamic':       this.type = SHT_DYNAMIC; break;\n            default:               this.type = sectionTypes.progbits;\n        }\n\n        switch(name)\n        {\n            case '.fini_array':\n            case '.init_array':\n                this.entrySize = 8; break;\n            case '.dynsym':  this.entrySize = 0x18; break;\n            case '.dynamic': this.entrySize = 0x10; break;\n            \n            default: this.entrySize = 0;\n        }\n    }\n\n    getRelocations()\n    {\n        let node = this.head, relocations = [];\n        while(node)\n        {\n            for(const reloc of node.statement.relocations)\n                relocations.push(new RelocEntry({ ...reloc, offset: node.statement.address + reloc.offset }));\n            node = node.next;\n        }\n        return relocations;\n    }\n}", "import { ASMError, token, next, setSyntax, currSyntax, currRange, ungetToken, setToken } from \"./parser.js\";\r\nimport { Section, sectionFlags, sections, sectionTypes, STT_SECTION } from \"./sections.js\";\r\nimport { Expression, readString, scanIdentifier } from \"./shuntingYard.js\";\r\nimport { Statement } from \"./statement.js\";\r\nimport { CommSymbol, fileSymbols, queueRecomp, referenceSymbol, SymbolDefinition } from \"./symbols.js\";\r\n\r\nexport const SYM_BINDS = {\r\n    'local': 0,\r\n    'global': 1,\r\n    'weak': 2\r\n};\r\n\r\nexport const SYM_TYPES = {\r\n    'no_type': 0,\r\n    'object': 1,\r\n    'function': 2,\r\n    'tls_object': 6\r\n};\r\n\r\nconst SYM_VISIBS = {\r\n    'internal': 1,\r\n    'hidden': 2,\r\n    'protected': 3,\r\n    'exported': 4,\r\n    'singleton': 5,\r\n    'eliminate': 6\r\n}\r\n\r\n// A directive is like a simpler instruction, except while an instruction is limited to\r\n// 15 bytes, a directive is infinitely flexible in size.\r\n\r\nconst DIRECTIVE_BUFFER_SIZE = 15;\r\n\r\nconst directives = {\r\n    equ:    -1,\r\n    set:    -1,\r\n    byte:   1,\r\n    short:  2,\r\n    word:   2, // .word = .short\r\n    hword:  2, // .hword = .short\r\n    value:  2, // .value = .short\r\n    '2byte':2, // .2byte = .short\r\n    int:    3,\r\n    long:   3, // .long = .int\r\n    '4byte':4, // .4byte = .int\r\n    quad:   4,\r\n    '8byte':4, // .8byte = .quad\r\n    octa:   5,\r\n    float:  6,\r\n    single: 6, // .single = .float\r\n    double: 7,\r\n    asciz:  8,\r\n    ascii:  9,\r\n    string: 9, // .string = .ascii\r\n    intel_syntax: 10,\r\n    att_syntax: 11,\r\n    text: 12,\r\n    data: 13,\r\n    bss: 14,\r\n    globl: 15,\r\n    global: 15,\r\n    weak: 16,\r\n    size: 17,\r\n    type: 18,\r\n    hidden: 19,\r\n    local: 20,\r\n    section: 21,\r\n    file: 22,\r\n    comm: 23\r\n};\r\n\r\nconst intelDirectives = {\r\n    '%assign': -1,\r\n    db: 0,\r\n    dw: directives.word,\r\n    dd: directives.long,\r\n    dq: directives.quad,\r\n    \".intel_syntax\": directives.intel_syntax,\r\n    \".att_syntax\": directives.att_syntax,\r\n    global: directives.global,\r\n    section: directives.section,\r\n    segment: directives.segment\r\n};\r\n\r\n/** Check if a given string corresponds to an existing directive\r\n * @param {string} directive\r\n * @param {boolean} intel\r\n */\r\nexport function isDirective(directive, intel)\r\n{\r\n    directive = directive.toLowerCase();\r\n    return intel ?\r\n        intelDirectives.hasOwnProperty(directive)\r\n    :\r\n        directive[0] == '.' && directives.hasOwnProperty(directive.slice(1));\r\n}\r\n\r\nexport function makeDirective(config, dir)\r\n{\r\n    dir = dir.toLowerCase();\r\n    let dirs = currSyntax.intel ? intelDirectives : directives;\r\n    if(!dirs.hasOwnProperty(dir))\r\n        throw new ASMError(\"Unknown directive\", config.range);\r\n    let dirID = dirs[dir];\r\n    switch(dirID)\r\n    {\r\n        case intelDirectives.db:\r\n        case directives.byte:\r\n        case directives.word:\r\n        case directives.int:\r\n        case directives.quad:\r\n        case directives.octa:\r\n        case directives.asciz:\r\n        case directives.ascii:\r\n            return new DataDirective(config, dirID);\r\n        \r\n        case directives.float:  return new FloatDirective(config, 0);\r\n        case directives.double: return new FloatDirective(config, 1);\r\n\r\n        case directives.intel_syntax: return new SyntaxDirective(config, true);\r\n        case directives.att_syntax:   return new SyntaxDirective(config, false);\r\n\r\n        case directives.section: return new SectionDirective(config);\r\n        \r\n        case directives.text: return new SectionDirective(config, sections[0]);\r\n        case directives.data: return new SectionDirective(config, sections[1]);\r\n        case directives.bss:  return new SectionDirective(config, sections[2]);\r\n        \r\n        case directives.local: return new SymBindDirective(config, SYM_BINDS.local);\r\n        case directives.globl: return new SymBindDirective(config, SYM_BINDS.global);\r\n        case directives.weak:  return new SymBindDirective(config, SYM_BINDS.weak);\r\n        \r\n        case directives.size:  return new SymSizeDirective(config);\r\n        case directives.type:  return new SymTypeDirective(config);\r\n\r\n        case directives.hidden: return new SymHiddenDirective(config)\r\n\r\n        case directives.file:  return new FileDirective(config);\r\n\r\n        case directives.equ:\r\n            let name = token, opcodeRange = currRange;\r\n            if(!currSyntax.intel && next() !== ',')\r\n                throw new ASMError(\"Expected ','\");\r\n            return new SymbolDefinition({ ...config, name, opcodeRange });\r\n        \r\n        case directives.comm: return new CommSymbol(config);\r\n    }\r\n}\r\n\r\nclass SectionDirective extends Statement\r\n{\r\n    /** @param {Section} section */\r\n    constructor(config, section = null)\r\n    {\r\n        let flags = 0, type = sectionTypes.progbits, attribRange = null;\r\n        if(section === null)\r\n        {\r\n            let sectionName = '';\r\n            while(token != ',' && token != ';' && token != '\\n')\r\n            {\r\n                sectionName += token;\r\n                next();\r\n            }\r\n            if(sectionName == '')\r\n                throw new ASMError(\"Expected section name\");\r\n            \r\n            section = sections.find(x => x.name == sectionName) ?? null;\r\n            \r\n            if(token == ',')\r\n            {\r\n                attribRange = currRange;\r\n                flags = 0;\r\n                for(const byte of readString(next()).bytes)\r\n                {\r\n                    const char = String.fromCharCode(byte);\r\n                    if(!sectionFlags.hasOwnProperty(char))\r\n                        throw new ASMError(`Unknown flag '${char}'`);\r\n                    flags |= sectionFlags[char];\r\n                }\r\n\r\n                if(next() == ',')\r\n                {\r\n                    if(next() != '@')\r\n                        throw new ASMError(\"Expected '@'\");\r\n                    const sectionType = next();\r\n                    if(!sectionTypes.hasOwnProperty(sectionType))\r\n                        throw new ASMError(\"Unknown section type\");\r\n                    type = sectionTypes[sectionType];\r\n                    next();\r\n                }\r\n                attribRange = attribRange.until(currRange);\r\n            }\r\n\r\n            if(section === null)\r\n                sections.push(section = new Section(sectionName));\r\n            if(section.persistent && attribRange)\r\n                throw new ASMError(`Can't give attributes to ${section.name}`, attribRange);\r\n        }\r\n        super({ ...config, maxSize: 0, section });\r\n        section.entryPoints.push(this);\r\n        this.switchSection = true;\r\n        this.sectionAttributes = attribRange ? { flags, type } : null;\r\n        this.attribRange = attribRange;\r\n\r\n        if(this.sectionAttributes)\r\n            try { this.recompile(); } catch(e) { this.error = e; }\r\n    }\r\n\r\n    recompile()\r\n    {\r\n        this.error = null;\r\n        if(this.section.entryPoints.some(x => x !== this && !x.removed && !x.error && x.sectionAttributes !== null))\r\n            throw new ASMError(\"Attributes already set for this section\", this.attribRange);\r\n        this.section.flags = this.sectionAttributes.flags;\r\n        this.section.type = this.sectionAttributes.type;\r\n    }\r\n\r\n    remove()\r\n    {\r\n        this.section.entryPoints.splice(this.section.entryPoints.indexOf(this), 1);\r\n        if(this.section.entryPoints.length == 0)\r\n        {\r\n            if(!this.section.persistent)\r\n            {\r\n                this.section.head.statement.remove();\r\n                sections.splice(sections.indexOf(this.section), 1);\r\n            }\r\n        }\r\n        else if(this.sectionAttributes !== null)\r\n        {\r\n            const otherDefinition = this.section.entryPoints.find(entry => entry.sectionAttributes !== null);\r\n            if(otherDefinition)\r\n                queueRecomp(otherDefinition);\r\n            else\r\n                this.section.flags = 0;\r\n        }\r\n    }\r\n}\r\n\r\nclass SyntaxDirective extends Statement\r\n{\r\n    constructor(config, intel)\r\n    {\r\n        // Set the syntax now so we can correctly skip comments\r\n        const prevSyntax = currSyntax;\r\n        setSyntax({ prefix: currSyntax.prefix, intel });\r\n\r\n        const prefSpecifier = token.toLowerCase();\r\n        let prefix = !intel;\r\n\r\n        if(prefSpecifier == 'prefix')\r\n            prefix = true;\r\n        else if(prefSpecifier == 'noprefix')\r\n            prefix = false;\r\n        else if(prefSpecifier != '\\n' && prefSpecifier != ';')\r\n        {\r\n            setSyntax(prevSyntax);\r\n            throw new ASMError(\"Expected 'prefix' or 'noprefix'\");\r\n        }\r\n        if(token != '\\n' && token != ';')\r\n            next();\r\n        super({ ...config, maxSize: 0, syntax: { intel, prefix } });\r\n        this.switchSyntax = true;\r\n    }\r\n}\r\n\r\nclass DataDirective extends Statement\r\n{\r\n    constructor(config, dirID)\r\n    {\r\n        super({ ...config, maxSize: DIRECTIVE_BUFFER_SIZE });\r\n        this.outline = null;\r\n        this.floatPrec = 0;\r\n\r\n        let appendNullByte = 0;\r\n        \r\n        try\r\n        {\r\n            switch(dirID)\r\n            {\r\n                case intelDirectives.db:  this.compileValues(1, true); break;\r\n                case directives.byte:     this.compileValues(1); break;\r\n                case directives.word:     this.compileValues(2); break;\r\n                case directives.int:      this.compileValues(4); break;\r\n                case directives.quad:     this.compileValues(8); break;\r\n                case directives.octa:     this.compileValues(16); break;\r\n\r\n                case directives.asciz:\r\n                    appendNullByte = 1;\r\n                case directives.ascii:\r\n                    this.bytes = new Uint8Array();\r\n                    do\r\n                    {\r\n                        if(token[0] == '\"')\r\n                        {\r\n                            const string = readString(token);\r\n                            this.append(string, string.bytes.length + appendNullByte);\r\n                        }\r\n                        else\r\n                            throw new ASMError(\"Expected string\");\r\n                    } while(next() == ',' && next());\r\n                    break;\r\n            }\r\n        }\r\n        catch(e)\r\n        {\r\n            this.error = e;\r\n            while(token != ';' && token != '\\n')\r\n                next();\r\n        }\r\n    }\r\n\r\n    append({ bytes, lineEnds }, length = bytes.length)\r\n    {\r\n        const temp = new Uint8Array(this.length + length + 1);\r\n        temp.set(this.bytes.subarray(0, this.length));\r\n        temp.set(bytes, this.length);\r\n        this.bytes = temp;\r\n        for(const lineEnd of lineEnds)\r\n            this.lineEnds.push(this.length + lineEnd);\r\n        this.length += length;\r\n    }\r\n\r\n    compileValues(valSize, acceptStrings = false)\r\n    {\r\n        this.valSize = valSize;\r\n        let expression, needsRecompilation = false;\r\n        this.outline = [];\r\n        try {\r\n            do\r\n            {\r\n                if(token[0] === '\"')\r\n                {\r\n                    if(acceptStrings)\r\n                    {\r\n                        const string = readString(token);\r\n                        this.outline.push(string);\r\n                        //this.append(string);\r\n                    }\r\n                    else\r\n                        throw new ASMError(\"Unexpected string\");\r\n                    next();\r\n                }\r\n                else\r\n                {\r\n                    expression = new Expression(this);\r\n                    if(expression.hasSymbols)\r\n                        needsRecompilation = true;\r\n                    this.outline.push({ expression });\r\n                }\r\n            } while(token === ',' && next());\r\n            this.removed = false;\r\n            this.compile();\r\n        }\r\n        finally\r\n        {\r\n            if(!needsRecompilation)\r\n                this.outline = null;\r\n        }\r\n    }\r\n\r\n    compile()\r\n    {\r\n        let op, outlineLength = this.outline.length;\r\n        const startAddr = this.address;\r\n        for(let i = 0; i < outlineLength; i++)\r\n        {\r\n            op = this.outline[i];\r\n            try\r\n            {\r\n                if(op.bytes)\r\n                    this.append(op);\r\n                else\r\n                {\r\n                    if(op.value === undefined || op.expression.hasSymbols)\r\n                        op.value = op.expression.evaluate(this, true);\r\n                    this.genValue(op.value, { size: this.valSize * 8 });\r\n                }\r\n                this.address = startAddr + this.length;\r\n            }\r\n            catch(e)\r\n            {\r\n                this.error = e;\r\n                outlineLength = i;\r\n                i = -1;\r\n                this.length = 0;\r\n            }\r\n        }\r\n        this.address = startAddr;\r\n    }\r\n\r\n    recompile()\r\n    {\r\n        this.clear();\r\n        this.error = null;\r\n\r\n        this.compile();\r\n    }\r\n\r\n    genByte(byte)\r\n    {\r\n        super.genByte(byte);\r\n\r\n        // Resize the array if necessary\r\n        if(this.length == this.bytes.length)\r\n        {\r\n            let temp = new Uint8Array(this.bytes.length + DIRECTIVE_BUFFER_SIZE);\r\n            temp.set(this.bytes);\r\n            this.bytes = temp;\r\n        }\r\n    }\r\n}\r\n\r\nclass FloatDirective extends Statement {\r\n    constructor(config, precision)\r\n    {\r\n        super({ ...config })\r\n        let values = [];\r\n        do\r\n        {\r\n            if(isNaN(token))\r\n                throw new ASMError(\"Expected number\");\r\n            if(token == '\\n')\r\n            {\r\n                this.error = new ASMError(\"Expected number\");\r\n                break;\r\n            }\r\n            values.push(token);\r\n        } while((next() == ',' && next()));\r\n\r\n        this.bytes = new Uint8Array((\r\n            precision > 0 ? new Float64Array(values) : new Float32Array(values)\r\n        ).buffer);\r\n        this.length = this.bytes.length;\r\n    }\r\n}\r\n\r\nclass SymInfo extends Statement\r\n{\r\n    addSymbol()\r\n    {\r\n        let name = token, range = currRange;\r\n        if(scanIdentifier(name, this.syntax.intel) != 'symbol')\r\n            return false;\r\n        next();\r\n        if(token != ',' && token != ';' && token != '\\n')\r\n        {\r\n            ungetToken();\r\n            setToken(name);\r\n            return false;\r\n        }\r\n        \r\n        const symbol = referenceSymbol(this, name, true);\r\n        if(symbol.type == STT_SECTION)\r\n            throw new ASMError(\"Can't modify section labels\");\r\n        this.symbols.push({ range, symbol });\r\n        return true;\r\n    }\r\n\r\n    constructor(config, name, proceedings = true)\r\n    {\r\n        super({ ...config, maxSize: 0 });\r\n        this.symbols = [];\r\n        if(!this.addSymbol())\r\n            throw new ASMError(\"Expected symbol name\");\r\n        this.infoName = name;\r\n        this.setting = [name];\r\n        \r\n        while(true)\r\n        {\r\n            if(token != ',')\r\n            {\r\n                if(proceedings)\r\n                    throw new ASMError(\"Expected ','\");\r\n                break;\r\n            }\r\n            next()\r\n            if(!this.addSymbol())\r\n                break;\r\n        }\r\n    }\r\n\r\n    compile()\r\n    {\r\n        this.removed = false;\r\n        for(const { symbol, range } of this.symbols)\r\n        {\r\n            for(const info of this.setting)\r\n                if(symbol.definitions.some(x => x !== this && !x.removed && !x.error && x.setting?.includes(info)))\r\n                    throw new ASMError(`${this.infoName} already set for this symbol`, range);\r\n            this.setInfo(symbol);\r\n        }\r\n    }\r\n\r\n    recompile()\r\n    {\r\n        this.error = null;\r\n        this.compile();\r\n    }\r\n\r\n    remove()\r\n    {\r\n        super.remove();\r\n        for(const info of this.setting)\r\n            for(const { symbol } of this.symbols) for(const def of symbol.definitions)\r\n                if(!def.removed && def.setting?.includes(info))\r\n                    queueRecomp(def);\r\n    }\r\n}\r\n\r\nclass SymBindDirective extends SymInfo\r\n{\r\n    constructor(config, bind)\r\n    {\r\n        super(config, 'Binding', false);\r\n        this.binding = bind;\r\n        try { this.compile(); } catch(e) { this.error = e; }\r\n    }\r\n\r\n    setInfo(symbol)\r\n    {\r\n        symbol.bind = this.binding;\r\n    }\r\n    remove()\r\n    {\r\n        super.remove();\r\n        for(const { symbol } of this.symbols)\r\n            symbol.bind = undefined;\r\n    }\r\n}\r\n\r\nclass SymSizeDirective extends SymInfo\r\n{\r\n    constructor(config)\r\n    {\r\n        super(config, 'Size');\r\n        this.expression = new Expression(this);\r\n        try { this.compile(); } catch(e) { this.error = e; }\r\n    }\r\n\r\n    compile()\r\n    {\r\n        this.value = this.expression.evaluate(this, false, true);\r\n        super.compile();\r\n    }\r\n\r\n    setInfo(symbol)\r\n    {\r\n        symbol.size = this.value.addend;\r\n    }\r\n\r\n    remove()\r\n    {\r\n        super.remove();\r\n        for(const { symbol } of this.symbols)\r\n            symbol.size = undefined;\r\n    }\r\n}\r\n\r\nclass SymTypeDirective extends SymInfo\r\n{\r\n    constructor(config)\r\n    {\r\n        super(config, 'Type');\r\n        this.visib = undefined;\r\n        if(token != '@')\r\n            throw new ASMError(\"Expected '@'\");\r\n        let type = next().toLowerCase();\r\n        if(!SYM_TYPES.hasOwnProperty(type))\r\n            throw new ASMError(\"Unknown symbol type\");\r\n        this.type = SYM_TYPES[type];\r\n        \r\n        if(next() == ',')\r\n        {\r\n            this.setting.push('Visibility');\r\n            if(next() != '@')\r\n                throw new ASMError(\"Expected '@'\");\r\n            let visib = next().toLowerCase();\r\n            if(!SYM_VISIBS.hasOwnProperty(visib))\r\n                throw new ASMError(\"Unknown symbol visibility\");\r\n            this.visib = SYM_VISIBS[visib];\r\n            next();\r\n        }\r\n\r\n        try { this.compile(); } catch(e) { this.error = e; }\r\n    }\r\n\r\n    setInfo(symbol)\r\n    {\r\n        symbol.type = this.type;\r\n        symbol.visibility = this.visib;\r\n    }\r\n\r\n    remove()\r\n    {\r\n        super.remove();\r\n        for(const { symbol } of this.symbols)\r\n        {\r\n            symbol.type = undefined;\r\n            symbol.visibility = undefined;\r\n        }\r\n    }\r\n}\r\n\r\nclass SymHiddenDirective extends SymInfo\r\n{\r\n    constructor(config)\r\n    {\r\n        super(config, 'Visibility', false);\r\n        try { this.compile(); } catch(e) { this.error = e; }\r\n    }\r\n\r\n    setInfo(symbol)\r\n    {\r\n        symbol.visibility = SYM_VISIBS.hidden;\r\n    }\r\n    remove()\r\n    {\r\n        super.remove();\r\n        for(const { symbol } of this.symbols)\r\n            symbol.visibility = undefined;\r\n    }\r\n}\r\n\r\nconst decoder = new TextDecoder();\r\nclass FileDirective extends Statement\r\n{\r\n    constructor(config)\r\n    {\r\n        super({ ...config, maxSize: 0 });\r\n        try\r\n        {\r\n            this.filename = decoder.decode(readString(token).bytes);\r\n        }\r\n        catch(e)\r\n        {\r\n            throw new ASMError(\"Bad string\");\r\n        }\r\n        next();\r\n        fileSymbols.push(this.filename);\r\n    }\r\n\r\n    remove()\r\n    {\r\n        fileSymbols.splice(fileSymbols.indexOf(this.filename), 1);\r\n    }\r\n}", "import { createBitfieldClass } from \"./bitfield.js\";\r\nimport { currBitness } from \"./compiler.js\";\r\nimport { Instruction } from \"./instructions.js\";\r\nimport { Operand, OPT, suffixes } from \"./operands.js\";\r\nimport { ASMError } from \"./parser.js\";\r\nimport { queueRecomp } from \"./symbols.js\";\r\n\r\nconst REG_MOD = -1, REG_OP = -2;\r\n/**\r\n * @type {Object.<string, OperandType>}\r\n */\r\nconst OPC = {\r\n    r: OPT.REG,\r\n    v: OPT.VEC,\r\n    i: OPT.IMM,\r\n    j: OPT.REL,\r\n    m: OPT.MEM,\r\n    s: OPT.SEG,\r\n    f: OPT.ST,\r\n    b: OPT.BND,\r\n    k: OPT.MASK,\r\n    c: OPT.CTRL,\r\n    d: OPT.DBG,\r\n    g: OPT.VMEM\r\n};\r\n\r\nconst sizers = Object.assign({f: 48}, suffixes);\r\n\r\n\r\n// To reduce memory use, operand catchers are cached and reused in the future\r\nvar opCatcherCache = {};\r\nconst SIZETYPE_IMPLICITENC = 1;\r\n\r\nexport const EvexPermits = createBitfieldClass([\r\n    \"MASK\", \"ZEROING\", \"BROADCAST_32\", \"BROADCAST_64\", \"SAE\",\r\n    \"ROUNDING\", \"FORCEW\", \"FORCE\", \"FORCE_MASK\"\r\n]);\r\n\r\nfunction parseEvexPermits(string)\r\n{\r\n    let permits = new EvexPermits();\r\n    for(let c of string)\r\n    {\r\n        switch(c)\r\n        {\r\n            case 'k': permits.MASK = true; break;\r\n            case 'K': permits.FORCE_MASK = permits.MASK = true; break;\r\n            case 'z': permits.ZEROING = true; break;\r\n            case 'b': permits.BROADCAST_32 = true; break;\r\n            case 'B': permits.BROADCAST_64 = true; break;\r\n            case 's': permits.SAE = true; break;\r\n            case 'r': permits.ROUNDING = true; break;\r\n            case 'w': permits.FORCEW = true; break;\r\n            case 'f': permits.FORCE = true; break\r\n        }\r\n    }\r\n    return permits;\r\n}\r\n\r\nfunction getSizes(format)\r\n{\r\n    let sizes = { list: [], def: undefined, defVex: undefined, memory: undefined };\r\n    for(let i = 0; i < format.length; i++)\r\n    {\r\n        let defaultSize = false, defaultVexSize = false, memorySize = false, size = 0, sizeChar = format[i];\r\n        if(sizeChar == '$') // $ prefix means this size should be encoded without a prefix\r\n            size |= SIZETYPE_IMPLICITENC, sizeChar = format[++i];\r\n        if(sizeChar == '#') // # prefix means this size should be defaulted to if the operand's size is ambiguous\r\n            defaultSize = true, sizeChar = format[++i];\r\n        if(sizeChar == '~') // ~ prefix means the same as # but for VEX mode only\r\n            defaultVexSize = true, sizeChar = format[++i];\r\n        if(sizeChar == '|') // | prefix means this size applies if and only if the operand is memory\r\n            memorySize = true, sizeChar = format[++i];\r\n\r\n        if(sizeChar < 'a') // Capital letters are shorthand for the combination $# (default and without prefix)\r\n            defaultSize = true, size |= sizers[sizeChar.toLowerCase()] | SIZETYPE_IMPLICITENC;\r\n        else\r\n            size |= sizers[sizeChar];\r\n        \r\n        if(memorySize)\r\n            sizes.memory = size;\r\n        else\r\n            sizes.list.push(size);\r\n        if(defaultSize)\r\n            sizes.def = size;\r\n        if(defaultVexSize)\r\n            sizes.defVex = size;\r\n    }\r\n    return sizes;\r\n}\r\n\r\nconst sizeLen = x => x == 32 ? 4n : x == 16 ? 2n : 1n;\r\nconst absolute = x => x < 0n ? ~x : x;\r\n\r\n/**\r\n * @typedef {Object} VexData\r\n * @property {boolean} needed\r\n * @property {boolean} evex\r\n * @property {number} mask\r\n * @property {boolean} zeroing\r\n * @property {number|null} round\r\n * @property {number|null} broadcast\r\n * @property {Operand} broadcastOperand\r\n */\r\n\r\n/** Operand catchers\r\n * @param {string} format \r\n */\r\nexport class OpCatcher\r\n{\r\n    /**\r\n     * Constructor\r\n     * @param {string} format \r\n     */\r\n    constructor(format)\r\n    {\r\n        opCatcherCache[format] = this; // Cache this op catcher\r\n        let i = 1;\r\n        this.sizes = [];\r\n\r\n        // First is the operand type\r\n        this.forceRM = format[0] == '^';\r\n        this.vexOpImm = format[0] == '<';\r\n        this.vexOp = this.vexOpImm || format[0] == '>';\r\n        this.moffset = format[0] == '%'; // Only used twice in the entire instruction set\r\n        if(this.forceRM || this.vexOp || this.moffset)\r\n            format = format.slice(1);\r\n        this.carrySizeInference = format[0] != '*';\r\n        if(!this.carrySizeInference)\r\n            format = format.slice(1);\r\n        let opType = format[0];\r\n        this.acceptsMemory = \"rvbkm\".includes(opType);\r\n        this.unsigned = opType == 'i';\r\n        this.type = OPC[opType.toLowerCase()];\r\n        this.forceRM = this.forceRM || this.acceptsMemory || this.type === OPT.VMEM;\r\n\r\n        this.carrySizeInference = this.carrySizeInference && this.type !== OPT.IMM && this.type !== OPT.MEM;\r\n        \r\n        // Optional argument: value for implicit operands\r\n        this.implicitValue = null;\r\n        if(format[1] == '_')\r\n        {\r\n            this.implicitValue = parseInt(format[2]);\r\n            i = 3;\r\n        }\r\n\r\n        // Next are the sizes\r\n        this.defSize = this.defVexSize = -1;\r\n\r\n        if(format[i] == '!')\r\n        {\r\n            this.sizes = 0;\r\n            this.hasByteSize = false;\r\n        }\r\n        else if(format[i] == '/')\r\n        {\r\n            this.sizes = -2;\r\n            this.hasByteSize = false;\r\n            this.sizeDivisor = +(format[i + 1] || 2);\r\n        }\r\n        else\r\n        {\r\n            let sizeData = getSizes(format.slice(i));\r\n            this.sizes = sizeData.list;\r\n            if(sizeData.def)\r\n                this.defSize = this.defVexSize = sizeData.def;\r\n            if(sizeData.defVex)\r\n                this.defVexSize = sizeData.defVex;\r\n            if(sizeData.memory)\r\n                this.memorySize = sizeData.memory;\r\n            this.hasByteSize = this.sizes.some(x => (x & 8) === 8);\r\n        }\r\n\r\n        if(this.sizes.length == 0)\r\n        {\r\n            if(!this.type.hasSize)\r\n                this.sizes = 0; // Meaning, size doesn't matter\r\n            else\r\n                this.sizes = -1; // Meaning, use the previously parsed size to catch\r\n        }\r\n    }\r\n\r\n    /** Attempt to \"catch\" a given operand.\r\n     * @param {Operand} operand\r\n     * @param {number} prevSize\r\n     * @param {boolean} isVex\r\n     * @returns {number|null} The operand's corrected size on success, null on failure\r\n     */\r\n    catch(operand, prevSize, isVex)\r\n    {\r\n        // Check that the sizes match\r\n        let opSize = this.moffset ? operand.dispSize : this.unsigned ? operand.unsignedSize : operand.size;\r\n        let rawSize, size = 0, found = false;\r\n        let defSize = isVex ? this.defVexSize : this.defSize;\r\n\r\n        if(isNaN(opSize))\r\n        {\r\n            if(operand.type === OPT.MEM && this.memorySize)\r\n                return this.memorySize;\r\n\r\n            // For unknown-sized operands, if possible, choose the default size\r\n            if(defSize > 0)\r\n                return defSize;\r\n            else if(this.moffset)\r\n            {\r\n                // Moffsets are only available in 64-bit mode\r\n                if(currBitness == 64 && operand.value.inferSize() == 64)\r\n                    opSize = 64;\r\n                else\r\n                    return null;\r\n            }\r\n            else if(this.sizes == -2)\r\n            {\r\n                opSize = (prevSize & ~7) / this.sizeDivisor;\r\n                if(operand.type.isVector && (opSize < 128 || this.sizeDivisor > 2)) // XMM register minimum\r\n                    opSize = 128;\r\n            }\r\n            else // If a default size isn't available, use the previous size\r\n                opSize = prevSize & ~7;\r\n        }\r\n        else if(this.type === OPT.IMM && defSize > 0 && defSize < opSize) // Allow immediates to be downcast if necessary\r\n            return defSize;\r\n\r\n        /* If a memory size has been specified and a memory\r\n        size is enforced, check that the two match */\r\n        if(operand.type === OPT.MEM && this.memorySize)\r\n            return operand.size == this.memorySize ? this.memorySize : null;\r\n\r\n        // For unknown-sized operand catchers, compare against the previous size\r\n        if(this.sizes == -1)\r\n        {\r\n            rawSize = prevSize & ~7;\r\n            if(opSize == rawSize || (operand.type === OPT.IMM && opSize < rawSize))\r\n                return Math.max(0, prevSize);\r\n            return null;\r\n        }\r\n\r\n        if(this.sizes == -2)\r\n        {\r\n            rawSize = (prevSize & ~7) / this.sizeDivisor;\r\n            if(operand.type.isVector && (rawSize < 128 || this.sizeDivisor > 2))\r\n                rawSize = 128;\r\n            if(opSize == rawSize)\r\n                return opSize | SIZETYPE_IMPLICITENC;\r\n            return null;\r\n        }\r\n\r\n        if(this.sizes !== 0)\r\n        {\r\n            for(size of this.sizes)\r\n            {\r\n                // No 64-bit sized R or R/M operands in 32-bit mode\r\n                if(size == 64 && currBitness == 32 && this.type == OPT.REG)\r\n                    continue;\r\n\r\n                rawSize = size & ~7;\r\n                if(opSize == rawSize || ((this.type === OPT.IMM || this.type === OPT.REL) && opSize < rawSize)) // Allow immediates and relatives to be upcast\r\n                {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if(!found)\r\n                return null;\r\n        }\r\n\r\n        return size;\r\n    }\r\n}\r\n\r\n/**\r\n * An operation (or \"mnemonic variation\") can be thought of as an\r\n * overloaded instance of a mnemonic\r\n */\r\nexport class Operation\r\n{\r\n    /**\r\n     * Constructor\r\n     * @param {string[]} format \r\n     */\r\n    constructor(format)\r\n    {\r\n        this.vexBase = 0;\r\n        this.evexPermits = null;\r\n        this.actuallyNotVex = false;\r\n        this.vexOnly = false;\r\n        this.requireMask = false;\r\n        this.requireBitness = null;\r\n\r\n        // Interpreting the opcode\r\n        this.forceVex = format[0][0] == 'V';\r\n        this.vexOnly = format[0][0] == 'v';\r\n        if(\"vVwl!xX\".includes(format[0][0]))\r\n        {\r\n            let specializers = format.shift();\r\n            if(specializers.includes('w')) this.vexBase |= 0x8000;\r\n            if(specializers.includes('l')) this.vexBase |= 0x400;\r\n            if(specializers.includes('!'))\r\n                this.actuallyNotVex = true; // For non-VEX instructions starting with V\r\n            if(specializers.includes('x')) this.requireBitness = 32;\r\n            if(specializers.includes('X')) this.requireBitness = 64;\r\n        }\r\n        let [opcode, extension] = format.shift().split('.');\r\n\r\n        // Op difference (the value to add to the opcode if the size isn't 8)\r\n        let adderSeparator = opcode.indexOf('+');\r\n        if(adderSeparator < 0)\r\n            adderSeparator = opcode.indexOf('-');\r\n        if(adderSeparator >= 0)\r\n        {\r\n            this.opDiff = parseInt(opcode.slice(adderSeparator));\r\n            opcode = opcode.slice(0, adderSeparator);\r\n        }\r\n        else\r\n            this.opDiff = 1;\r\n\r\n        if(opcode.includes(')'))\r\n            [this.prefix, this.code] = opcode.split(')').map(x => parseInt(x, 16));\r\n        else\r\n        {\r\n            this.code = parseInt(opcode, 16);\r\n            this.prefix = null;\r\n        }\r\n\r\n        // Interpreting the extension\r\n        if(extension === undefined) // Default values\r\n        {\r\n            this.extension = REG_MOD;\r\n            this.modExtension = null;\r\n        }\r\n        else\r\n        {\r\n            if(extension[0] == 'o')\r\n                this.extension = REG_OP;\r\n            else\r\n                this.extension = parseInt(extension[0]);\r\n            this.modExtension = extension[1] ? parseInt(extension[1]) : null;\r\n        }\r\n\r\n        this.allVectors = false;\r\n        this.relativeSizes = null;\r\n        this.allowVex = this.forceVex || format.some(op => op.includes('>'));\r\n        this.maxSize = 0;\r\n\r\n        this.vexOpCatchers = this.allowVex ? [] : null;\r\n\r\n        // What follows is a list of operand specifiers\r\n        /** @type { OpCatcher[] } */\r\n        this.opCatchers = [];\r\n        if(format.length == 0)\r\n            return;\r\n\r\n        let opCatcher;\r\n\r\n        for(let operand of format)\r\n        {\r\n            if(operand == '>') // Empty VEX operands shouldn't be counted\r\n                continue;\r\n            if(operand[0] == '{') // EVEX permits\r\n            {\r\n                this.fixedDispMul = null;\r\n                let permitsString = operand.slice(1).replace(/T[0-9R]/g, substr => {\r\n                    let type = substr[1];\r\n                    if(type == 'R')\r\n                        this.fixedDispMul = 'R';\r\n                    else\r\n                        this.fixedDispMul = 1 << substr[1];\r\n                    return '';\r\n                });\r\n                this.evexPermits = parseEvexPermits(permitsString);\r\n                if(this.evexPermits.FORCE)\r\n                    this.vexOnly = true;\r\n                if(this.evexPermits.FORCE_MASK)\r\n                    this.requireMask = true;\r\n                continue;\r\n            }\r\n            opCatcher = opCatcherCache[operand] || new OpCatcher(operand);\r\n            if(opCatcher.type === OPT.REL) this.relativeSizes = opCatcher.sizes;\r\n            if(!opCatcher.vexOp || this.forceVex) this.opCatchers.push(opCatcher);\r\n            if(this.vexOpCatchers !== null) this.vexOpCatchers.push(opCatcher);\r\n\r\n            if(Array.isArray(opCatcher.sizes))\r\n            {\r\n                let had64 = false;\r\n                for(let size of opCatcher.sizes)\r\n                {\r\n                    if(size > this.maxSize)\r\n                        this.maxSize = size & ~7;\r\n                    if((size & ~7) == 64)\r\n                        had64 = true;\r\n                    else if(had64 && (size & ~7) > 64)\r\n                        this.allVectors = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Generate the necessary vex info\r\n        if(this.allowVex || this.forceVex)\r\n        {\r\n            this.vexBase |= 0x7800 |\r\n                ([0x0F, 0x0F38, 0x0F3A].indexOf(this.code >> 8) + 1)\r\n                | ([null, 0x66, 0xF3, 0xF2].indexOf(this.prefix) << 8);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if the given VEX data is appropriate for this operation\r\n     * @param {VexData} vexInfo\r\n     * @returns {boolean}\r\n     */\r\n    validateVEX(vexInfo)\r\n    {\r\n        if(vexInfo.needed)\r\n        {\r\n            if(this.actuallyNotVex || !this.allowVex)\r\n                return false;\r\n            if(vexInfo.evex)\r\n            {\r\n                if(\r\n                    this.evexPermits === null ||\r\n                    !this.evexPermits.MASK && vexInfo.mask > 0 ||\r\n                    !(this.evexPermits.BROADCAST_32 || this.evexPermits.BROADCAST_64) && vexInfo.broadcast !== null ||\r\n                    !this.evexPermits.ROUNDING && vexInfo.round > 0 ||\r\n                    !this.evexPermits.SAE && vexInfo.round === 0 ||\r\n                    !this.evexPermits.ZEROING && vexInfo.zeroing)\r\n                    return false;\r\n            }\r\n            else if(this.evexPermits?.FORCE)\r\n                vexInfo.evex = true;\r\n        }\r\n        else if(this.vexOnly || this.evexPermits?.FORCE)\r\n            return false;\r\n        \r\n        if(this.evexPermits?.FORCE_MASK && vexInfo.mask == 0)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Attempt to fit the operand list into the operation\r\n     * @param {Operand[]} operands\r\n     * @param {Instruction} instr\r\n     * @param {VexData} vexInfo\r\n     * @returns an object containing encoding data, or null if the operand\r\n     * list didn't fit\r\n     */\r\n    fit(operands, instr, vexInfo)\r\n    {\r\n        if(!this.validateVEX(vexInfo))\r\n            return null;\r\n\r\n        let adjustByteOp = false, overallSize = 0, rexw = false;\r\n\r\n        if(this.relativeSizes)\r\n        {\r\n            if(!(operands.length == 1 && operands[0].type === OPT.REL))\r\n                return null;\r\n            operands[0].size = this.getRelSize(operands[0], instr);\r\n        }\r\n\r\n        let opCatchers = vexInfo.needed ? this.vexOpCatchers : this.opCatchers;\r\n        if(operands.length != opCatchers.length)\r\n            return null; // Operand numbers must match\r\n        let correctedSizes = new Array(operands.length), size = -1, prevSize = -1, i, catcher;\r\n\r\n        for(i = 0; i < operands.length; i++)\r\n        {\r\n            catcher = opCatchers[i];\r\n            if(size > 0 || Array.isArray(catcher.sizes))\r\n            {\r\n                size = catcher.catch(operands[i], size, vexInfo.needed, vexInfo.broadcast !== null);\r\n                if(size === null)\r\n                    return null;\r\n            }\r\n            correctedSizes[i] = size;\r\n            if(size >= 512 && !vexInfo.evex) // Sometimes the 512 size is implicit\r\n            {\r\n                vexInfo.evex = true;\r\n                if(!this.validateVEX(vexInfo))\r\n                    return null;\r\n            }\r\n\r\n            if(!catcher.carrySizeInference)\r\n                size = prevSize; // Size shouldn't be inferred from some operands\r\n            prevSize = size;\r\n        }\r\n\r\n        // If the operand size specification wasn't in order,\r\n        // we'll have to redo the catching for the skipped operands\r\n        for(i = 0; i < operands.length; i++)\r\n        {\r\n            if(correctedSizes[i] < 0)\r\n            {\r\n                size = opCatchers[i].catch(operands[i], size, vexInfo.needed);\r\n                if(size === null)\r\n                    return null;\r\n                correctedSizes[i] = size;\r\n            }\r\n        }\r\n\r\n        // If we've gotten this far, hurray! All operands fit, and the operation can be encoded.\r\n        // Note that while the following operations can be merged into the previous loop, they may\r\n        // be redundant as we wouldn't know if the operation is encodable at all.\r\n        // In other words, this aids performance.\r\n\r\n        let reg = null, rm = null, vex = this.vexBase, imms = [], correctedOpcode = this.code, evexImm = null, relImm = null, moffs = null;\r\n        let extendOp = false, unsigned = false, dispMul = null;\r\n\r\n        let operand;\r\n\r\n        for(i = 0; i < operands.length; i++)\r\n        {\r\n            catcher = opCatchers[i], operand = operands[i];\r\n            size = correctedSizes[i];\r\n            if(catcher.moffset)\r\n                operand.dispSize = size & ~7;\r\n            else\r\n            {\r\n                operand.size = size & ~7;\r\n                if(operand.size != 0)\r\n                    operand.recordSizeUse(operand.size, catcher.unsigned);\r\n            }\r\n            if(catcher.unsigned)\r\n                unsigned = true;\r\n\r\n            if(operand.size == 64 && !(size & SIZETYPE_IMPLICITENC) && !this.allVectors)\r\n                rexw = true;\r\n            if(catcher.implicitValue === null)\r\n            {\r\n                if(operand.type === OPT.IMM)\r\n                    imms.push(operand);\r\n                else if(catcher.type === OPT.REL)\r\n                {\r\n                    relImm = operand;\r\n                    instr.ipRelative = true;\r\n                }\r\n                else if(catcher.moffset)\r\n                    moffs = operand;\r\n                else if(catcher.forceRM)\r\n                    rm = operand;\r\n                else if(catcher.vexOp)\r\n                {\r\n                    if(catcher.vexOpImm)\r\n                        evexImm = BigInt(operand.reg << 4);\r\n                    else\r\n                        vex = (vex & ~0x7800) | ((~operand.reg & 15) << 11);\r\n\r\n                    if(operand.reg >= 16)\r\n                        vex |= 0x80000; // EVEX.V'\r\n                }\r\n                else\r\n                    reg = operand;\r\n                if(operand.type === OPT.VEC && operand.size == 64 && vexInfo.needed)\r\n                    throw new ASMError(\"Can't encode MMX with VEX prefix\", operand.endPos);\r\n            }\r\n\r\n            // Overall size represents the highest non-implicitly encoded size\r\n            if(!catcher.moffset && overallSize < (size & ~7) && !(size & SIZETYPE_IMPLICITENC))\r\n                overallSize = size & ~7;\r\n\r\n            if(size >= 16)\r\n                adjustByteOp = adjustByteOp || catcher.hasByteSize;\r\n        }\r\n\r\n        if(this.extension == REG_OP)\r\n        {\r\n            correctedOpcode += reg.reg & 7;\r\n            extendOp = reg.reg > 7;\r\n            reg = null;\r\n        }\r\n        else if(this.extension != REG_MOD)\r\n        {\r\n            if(rm === null)\r\n            {\r\n                if(this.modExtension === null)\r\n                    rm = reg;\r\n                else\r\n                    rm = { type: OPT.MEM, reg: this.modExtension, value: null };\r\n            }\r\n            reg = {reg: this.extension};\r\n        }\r\n\r\n        vexInfo.needed = vexInfo.needed || this.forceVex;\r\n\r\n        if(vexInfo.needed)\r\n        {\r\n            if(this.allVectors)\r\n                vex |= 0x100; // 66 prefix\r\n\r\n            // Some additional EVEX data\r\n            if(vexInfo.evex)\r\n            {\r\n                vex |= 0x400; // This reserved bit is always set to 1\r\n                if(vexInfo.zeroing)\r\n                    vex |= 0x800000; // EVEX.z\r\n                if(vexInfo.round !== null)\r\n                {\r\n                    if(overallSize !== this.maxSize)\r\n                        throw new ASMError(\"Invalid vector size for embedded rounding\", vexInfo.roundingPos);\r\n                    if(vexInfo.round > 0)\r\n                        vexInfo.round--;\r\n                    vex |= (vexInfo.round << 21) | 0x100000; // EVEX.RC\r\n                }\r\n                else\r\n                {\r\n                    let sizeId = [128, 256, 512].indexOf(overallSize);\r\n                    vex |= sizeId << 21; // EVEX.L'L\r\n\r\n                    if(vexInfo.broadcast !== null)\r\n                    {\r\n                        let intendedSize = vexInfo.broadcastOperand.size;\r\n                        let baseSize = this.evexPermits.BROADCAST_32 ? 32 : 64;\r\n                        let broadcastSize = baseSize << vexInfo.broadcast;\r\n                        if(broadcastSize !== intendedSize)\r\n                            throw new ASMError(\"Invalid broadcast\", vexInfo.broadcastPos);\r\n                        vex |= 0x100000; // EVEX.b\r\n                        dispMul = baseSize >> 3;\r\n                    }\r\n                    else if(this.opCatchers.some(x => x.acceptsMemory && x.sizes == -2)) // \"Half\" tuple type\r\n                        dispMul = (overallSize >> 3) / this.opCatchers.find(x => x.sizes == -2).sizeDivisor;\r\n                    else if(this.opCatchers[0].type == OPT.VEC && !this.opCatchers[0].carrySizeInference) // Mem128 tuple type\r\n                        dispMul = 16;\r\n                    else if(this.opCatchers.some(x => x.memorySize)) // \"Tuple[x]\" tuple type\r\n                        dispMul = this.opCatchers.find(x => x.memorySize).memorySize >> 3;\r\n                    else if(this.fixedDispMul !== null) // \"Tuple scalar\" tuple type\r\n                    {\r\n                        if(this.fixedDispMul === 'R')\r\n                        {\r\n                            let memory = operands.find(x => x.type === OPT.MEM);\r\n                            if(memory)\r\n                                dispMul = memory.size >> 3;\r\n                        }\r\n                        else\r\n                            dispMul = this.fixedDispMul;\r\n                    }\r\n                    else // \"Full\" tuple type\r\n                        dispMul = overallSize >> 3;\r\n\r\n                    if(operands.some(x => x.type === OPT.VMEM)) // Vector-memories don't have displacement compression\r\n                        dispMul = null;\r\n                }\r\n                vex |= vexInfo.mask << 16; // EVEX.aaa\r\n                if(this.evexPermits.FORCEW)\r\n                    vex |= 0x8000;\r\n                if(reg.reg >= 16)\r\n                    vex |= 0x10, reg.reg &= 15; // EVEX.R'\r\n                if(rm.reg2 >= 16)\r\n                    vex |= 0x80000; // EVEX.V' sometimes serves as an extension to EVEX.X\r\n            }\r\n            else if(overallSize == 256)\r\n                vex |= 0x400;\r\n        }\r\n        else\r\n        {\r\n            if(overallSize > 128)\r\n            {\r\n                for(let reg of operands)\r\n                    if(reg.size > 128 && reg.endPos)\r\n                        throw new ASMError(\"YMM/ZMM registers can't be encoded without VEX\", reg.endPos);\r\n            }\r\n            for(let reg of operands)\r\n                if(reg.type === OPT.VEC && reg.reg >= 16 && reg.endPos)\r\n                    throw new ASMError(\"Registers with ID >= 16 can't be encoded without EVEX\", reg.endPos);\r\n        }\r\n\r\n        if(adjustByteOp)\r\n            correctedOpcode += this.opDiff;\r\n\r\n        return {\r\n            opcode: correctedOpcode,\r\n            size: overallSize,\r\n            rexw,\r\n            prefix: vexInfo.needed ? null : (this.allVectors && overallSize > 64 ? 0x66 : this.prefix),\r\n            extendOp,\r\n            /** @type {Operand} */ reg,\r\n            /** @type {Operand} */ rm,\r\n            vex: vexInfo.needed ? vex : null,\r\n            evexImm,\r\n            relImm,\r\n            imms,\r\n            unsigned,\r\n            moffs,\r\n            dispMul\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Predict a fitting size for a given relative operand\r\n     * @param {Operand} operand\r\n     * @param {Instruction} instr\r\n    */\r\n    getRelSize(operand, instr)\r\n    {\r\n        if(operand.value.isRelocatable())\r\n            return Math.max(...this.relativeSizes);\r\n        const target = operand.value.addend - BigInt(((this.code > 0xFF ? 2 : 1) + (this.prefix !== null ? 1 : 0)));\r\n        \r\n        // In x86-64 there are always either 1 or 2 possible sizes for a relative\r\n        if(this.relativeSizes.length == 1)\r\n        {\r\n            const size = this.relativeSizes[0];\r\n            if(absolute(target - sizeLen(size)) >= 1n << BigInt(size - 1))\r\n                throw new ASMError(`Can't fit offset in ${size >> 3} byte${size != 8 ? 's' : ''}`, operand.startPos.until(operand.endPos));\r\n            return size;\r\n        }\r\n        \r\n        // Now we have the second, more complicated case. There's a threshold between the two sizes we must find\r\n        let [small, large] = this.relativeSizes;\r\n        let smallLen = sizeLen(small), largeLen = sizeLen(large) + (this.opDiff > 256 ? 1n : 0n);\r\n\r\n        if(absolute(target - smallLen) >= 1n << BigInt(small - 1) || !operand.sizeAllowed(small, false))\r\n        {\r\n            if(small != operand.size && operand.sizeAllowed(small, false))\r\n            {\r\n                queueRecomp(instr);\r\n                return small;\r\n            }\r\n            if(absolute(target - largeLen) >= 1n << BigInt(large - 1))\r\n                throw new ASMError(`Can't fit offset in ${large >> 3} bytes`, operand.startPos.until(operand.endPos));\r\n            return large;\r\n        }\r\n        return small;\r\n    }\r\n\r\n    /**\r\n     * Check if a list of operands has the right types for this operation\r\n     * @param {Operand[]} operands \r\n     * @param {VexData} vexInfo \r\n     */\r\n    matchTypes(operands, vexInfo)\r\n    {\r\n        if(vexInfo.mask == 0 && this.requireMask)\r\n            return false;\r\n\r\n        let opCatchers = vexInfo.needed ? this.vexOpCatchers : this.opCatchers;\r\n        if(operands.length != opCatchers.length)\r\n            return false;\r\n\r\n        for(let i = 0; i < operands.length; i++)\r\n        {\r\n            const catcher = opCatchers[i], operand = operands[i];\r\n            if(\r\n                // Check that the types match\r\n                operand.type != catcher.type &&\r\n                !(operand.type === OPT.MEM && catcher.acceptsMemory)\r\n                ||\r\n                // In case of implicit operands, check that the values match\r\n                catcher.implicitValue !== null &&\r\n                catcher.implicitValue !== (operand.type === OPT.IMM ? Number(operand.value.addend) : operand.reg)\r\n                ||\r\n                // Super special case: if the operand is of type moffset,\r\n                // make sure it is only an offset\r\n                catcher.moffset && (operand.reg >= 0 || operand.reg2 >= 0)\r\n            )\r\n                return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n}", "export default `\r\naaa:x 37\r\naad\r\nx D50A\r\nx D5 ib\r\n\r\naam\r\nx D40A\r\nx D4 ib\r\n\r\naas:x 3F\r\n\r\nadcx:66)0F38F6 r Rlq\r\n\r\naddpd:66)0F58 v >V Vxyz {kzrBw\r\naddps:0F58 v >V Vxyz {kzrb\r\naddsd:F2)0F58 v >V Vx {kzrw\r\naddss:F3)0F58 v >V Vx {kzr\r\n\r\naddsubpd:66)0FD0 v >V Vxy\r\naddsubps:F2)0FD0 v >V Vxy\r\n\r\nadox:F3)0F38F6 r Rlq\r\naesdec:66)0F38DE v >V Vxyz {\r\naesdeclast:66)0F38DF v >V Vxyz {\r\naesenc:66)0F38DC v >V Vxyz {\r\naesenclast:66)0F38DD v >V Vxyz {\r\naesimc:66)0F38DB v Vx >\r\naeskeygenassist:66)0F3ADF ib v Vx >\r\nandn:V 0F38F2 r >Rlq R\r\n\r\nandpd:66)0F54 v >V Vxyz {kzBw\r\nandps:0F54 v >V Vxyz {kzb\r\n\r\nandnpd:66)0F55 v >V Vxyz {kzBw\r\nandnps:0F55 v >V Vxyz {kzb\r\n\r\nbextr:V 0F38F7 >Rlq r R\r\n\r\nblendpd:66)0F3A0D ib v >V Vxy\r\nblendps:66)0F3A0C ib v >V Vxy\r\n\r\nblendvpd\r\n66)0F3815 V_0x v V\r\nv 66)0F3A4B <Vxy v >V V\r\n\r\nblendvps\r\n66)0F3814 V_0x v V\r\nv 66)0F3A4A <Vxy v >V V\r\n\r\nblsi:V 0F38F3.3 r >Rlq\r\nblsmsk:V 0F38F3.2 r >Rlq\r\nblsr:V 0F38F3.1 r >Rlq\r\nbndcl:F3)0F1A rQ B\r\nbndcn:F2)0F1B rQ B\r\nbndcu:F2)0F1A rQ B\r\nbndldx:0F1A m B\r\nbndmk:F3)0F1B m B\r\n\r\nbndmov\r\n66)0F1A b B\r\n66)0F1B B b\r\n\r\nbndstx:0F1B B m\r\n\r\nbound:x 62 m Rwl\r\n\r\nbsf:0FBC r Rwlq\r\nbsr:0FBD r Rwlq\r\nbswap:0FC8.o Rlq\r\n\r\nbt\r\n0FA3 Rwlq r\r\n0FBA.4 iB rwlq\r\n\r\nbtc\r\n0FBB Rwlq r\r\n0FBA.7 iB rwlq\r\n\r\nbtr\r\n0FB3 Rwlq r\r\n0FBA.6 iB rwlq\r\n\r\nbts\r\n0FAB Rwlq r\r\n0FBA.5 iB rwlq\r\n\r\nbzhi:V 0F38F5 >Rlq r R\r\n\r\ncall\r\nE8 jl\r\nx FF.2 rwL\r\nX FF.2 rQ\r\nFF.3 mf\r\n\r\ncallw:x E8 jw\r\n\r\ncbtw/cbw:66)98\r\ncltd/cdq:99\r\ncltq/cdqe:X 48)98\r\nclac:0F01CA\r\nclc:F8\r\ncld:FC\r\ncldemote:0F1C.0 m\r\nclflush:0FAE.7 m\r\nclflushopt:66)0FAE.7 m\r\ncli:FA\r\nclrssbsy:F3)0FAE.6 m\r\nclts:0F06\r\nclwb:66)0FAE.6 m\r\ncmc:F5\r\n\r\ncmppd\r\n66)0FC2 ib v >V Vxy\r\n66)0FC2 ib v >Vxyz K {kBsfw\r\n\r\ncmpps\r\n0FC2 ib v >V Vxy\r\n0FC2 ib v >Vxyz K {kbsf\r\n\r\ncmps{bwlq:A6\r\n\r\ncmpsd\r\nF2)0FC2 ib v >V Vx\r\nF2)0FC2 ib v|Q >Vx K {ksfw\r\n\r\ncmpss\r\nF3)0FC2 ib v >V Vx\r\nF3)0FC2 ib v|l >Vx K {ksf\r\n\r\ncmpxchg:0FB0 Rbwlq r\r\ncmpxchg8b:0FC7.1 m\r\ncmpxchg16b:0FC7.1 m#q\r\n\r\ncomisd:66)0F2F v Vx > {sw\r\ncomiss:0F2F v Vx > {s\r\n\r\ncpuid:0FA2\r\n\r\ncrc32\r\nF2)0F38F0 rbwl RL\r\nF2)0F38F0 rbq Rq\r\n\r\ncvtdq2pd:F3)0FE6 v/ Vxyz > {kzb\r\ncvtdq2ps:0F5B v Vxyz > {kzbr\r\ncvtpd2dq:F2)0FE6 v#xy~z V/ > {kzBrw\r\ncvtpd2pi:66)0F2D vX VQ\r\ncvtpd2ps:66)0F5A v#xy~z V/ > {kzBrw\r\ncvtpi2pd:66)0F2A vQ Vx\r\ncvtpi2ps:0F2A vQ Vx\r\ncvtps2dq:66)0F5B v Vxyz > {kzbr\r\ncvtps2pd:0F5A v/ Vxyz > {kzbs\r\ncvtps2pi:0F2D vX VQ\r\ncvtsd2si:F2)0F2D v#x Rlq > {r\r\ncvtsd2ss:F2)0F5A vX >Vx Vx {kzrw\r\ncvtsi2sd:F2)0F2A rlq >Vx Vx {r\r\ncvtsi2ss:F3)0F2A rlq >Vx Vx {r\r\ncvtss2sd:F3)0F5A v >Vx Vx {kzs\r\ncvtss2si:F3)0F2D v#x Rlq > {r\r\ncvttpd2dq:66)0FE6 v#xy~z V/ > {kzBsw\r\ncvttpd2pi:66)0F2C vX VQ\r\ncvttps2dq:F3)0F5B v Vxyz > {kzbs\r\ncvttps2pi:0F2C vX VQ\r\ncvttsd2si:F2)0F2C v#x Rlq > {s\r\ncvttss2si:F3)0F2C v#x Rlq > {s\r\n\r\ncqto/cqo:X 48)99\r\ncwtd/cwd:66)99\r\ncwtl/cwde:98\r\n\r\ndaa:x 27\r\ndas:x 2F\r\n\r\ndec\r\nx 48.o Rwl\r\nFE.1 rbwlq\r\n\r\ndiv:F6.6 rbwlq\r\n\r\ndivpd:66)0F5E v >V Vxyz {kzBwr\r\ndivps:0F5E v >V Vxyz {kzbr\r\ndivsd:F2)0F5E v >V Vx {kzwr\r\ndivss:F3)0F5E v >V Vx {kzr\r\n\r\ndppd:66)0F3A41 ib v >V Vx\r\ndpps:66)0F3A40 ib v >V Vxy\r\n\r\nemms:0F77\r\nendbr32:F3)0F1EFB\r\nendbr64:F3)0F1EFA\r\nenter:C8 iW ib\r\nextractps:66)0F3A17 ib Vx rL > {\r\n\r\nf2xm1:D9F0\r\nfabs:D9E1\r\nfbld:DF.4 m\r\nfbstp:DF.6 m\r\nfchs:D9E0\r\nfclex:9BDBE2\r\nfcmovb:DA.0 F F_0\r\nfcmove:DA.1 F F_0\r\nfcmovbe:DA.2 F F_0\r\nfcmovu:DA.3 F F_0\r\nfcmovnb:DB.0 F F_0\r\nfcmovne:DB.1 F F_0\r\nfcmovnbe:DB.2 F F_0\r\nfcmovnu:DB.3 F F_0\r\nfcompp:DED9\r\nfcomi:DB.6 F F_0\r\nfcomip:DF.6 F F_0\r\nfcos:D9FF\r\nfdecstp:D9F6\r\nffree:DD.0 F\r\n\r\nfild\r\nDF.0 mW\r\nDB.0 ml\r\nDF.5 m$q\r\n\r\nfincstp:D9F7\r\nfinit:9BDBE3\r\n\r\nfist\r\nDF.2 mW\r\nDB.2 ml\r\n\r\nfistp\r\nDF.3 mW\r\nDB.3 ml\r\nDF.7 m$q\r\n\r\nfisttp\r\nDF.1 mW\r\nDB.1 ml\r\nDD.1 m$q\r\n\r\nfld\r\nD9.0 ml\r\nDD.0 m$q\r\nDB.5 mt\r\nD9.0 F\r\n\r\nfld1:D9E8\r\nfldl2t:D9E9\r\nfldl2e:D9EA\r\nfldpi:D9EB\r\nfldlg2:D9EC\r\nfldln2:D9ED\r\nfldz:D9EE\r\nfldcw:D9.5 m\r\nfldenv:D9.4 m\r\nfnclex:DBE2\r\nfninit:DBE3\r\nfnop:D9D0\r\nfnsave:DD.6 m\r\nfnstcw:D9.7 m\r\nfnstenv:D9.6 m\r\n\r\nfnstsw\r\nDD.7 m\r\nDFE0 R_0W\r\n\r\nfpatan:D9F3\r\nfprem:D9F8\r\nfprem1:D9F5\r\nfptan:D9F2\r\nfrndint:D9FC\r\nfrstor:DD.4 m\r\nfsave:9BDD.6 m\r\nfscale:D9FD\r\nfsin:D9FE\r\nfsincos:D9FB\r\nfsqrt:D9FA\r\n\r\nfst\r\nD9.2 ml\r\nDD.2 m$q\r\nDD.2 F\r\n\r\nfstcw:9BD9.7 m\r\nfstenv:9BD9.6 m\r\n\r\nfstp\r\nD9.3 ml\r\nDD.3 m$q\r\nDD.3 F\r\n\r\nfstpt:DB.7 m\r\n\r\nfstsw\r\n9BDD.7 m\r\n9BDFE0 R_0W\r\n\r\nftst:D9E4\r\n\r\nfucom\r\nDD.4 F\r\nDDE1\r\n\r\nfucomp\r\nDD.5 F\r\nDDE9\r\n\r\nfucompp:DAE9\r\nfucomi:DB.5 F F_0\r\nfucomip:DF.5 F F_0\r\nfwait:#wait\r\nfxam:D9E5\r\n\r\nfxch\r\nD9.1 F\r\nD9C9\r\n\r\nfxrstor:0FAE.1 m\r\nfxrstor64:X 0FAE.1 m#q\r\nfxsave:0FAE.0 m\r\nfxsave64:X 0FAE.0 m#q\r\nfxtract:D9F4\r\nfyl2x:D9F1\r\nfyl2xp1:D9F9\r\n\r\ngf2p8affineinvqb:w 66)0F3ACF ib v >V Vxyz {kzBw\r\ngf2p8affineqb:w 66)0F3ACE ib v >V Vxyz {kzBw\r\ngf2p8mulb:66)0F38CF v >V Vxyz {kz\r\n\r\nhaddpd:66)0F7C v >V Vxy\r\nhaddps:F2)0F7C v >V Vxy\r\n\r\nhlt:F4\r\n\r\nhsubpd:66)0F7D v >V Vxy\r\nhsubps:F2)0F7D v >V Vxy\r\n\r\nidiv:F6.7 rbwlq\r\n\r\nimul\r\nF6.5 rbwlq\r\n0FAF r Rwlq\r\n6B Ib r Rwlq\r\n69 iw rw Rw\r\n69 il r Rlq\r\n\r\nin\r\nE4 ib R_0bwl\r\nEC R_2W R_0bwl\r\n\r\ninc\r\nx 40.o Rwl\r\nFE.0 rbwlq\r\n\r\nincsspd:F3)0FAE.5 Rl\r\nincsspq:F3)0FAE.5 Rq\r\nins{bwl:6C\r\ninsertps:66)0F3A21 ib v >V Vx {\r\n\r\nint\r\nCC i_3b\r\nCD ib\r\n\r\nint1:F1\r\nint3:CC\r\ninto:x CE\r\ninvd:0F08\r\ninvlpg:0F01.7 m\r\ninvpcid:66)0F3882 m RQ\r\niret{wLq:CF\r\n\r\njmp\r\nEB-2 jbl\r\nx FF.4 rwL\r\nX FF.4 rQ\r\nFF.5 mf\r\n\r\njmpw:x E9 jw\r\n\r\njcxz:x 67)E3 jb\r\njecxz\r\nx E3 jb\r\nX 67)E3 jb\r\n\r\njrcxz:X E3 jb\r\n\r\nkaddb:Vl 66)0F4A ^K >K K\r\nkaddw:Vl 0F4A ^K >K K\r\nkaddd:Vlw 66)0F4A ^K >K K\r\nkaddq:Vlw 0F4A ^K >K K\r\n\r\nkandb:Vl 66)0F41 ^K >K K\r\nkandw:Vl 0F41 ^K >K K\r\nkandd:Vlw 66)0F41 ^K >K K\r\nkandq:Vlw 0F41 ^K >K K\r\n\r\nkandnb:Vl 66)0F42 ^K >K K\r\nkandnw:Vl 0F42 ^K >K K\r\nkandnd:Vlw 66)0F42 ^K >K K\r\nkandnq:Vlw 0F42 ^K >K K\r\n\r\nkmovb\r\nV 66)0F90 k K >\r\nV 66)0F91 K m >\r\nV 66)0F92 ^Rl K >\r\nV 66)0F93 ^K Rl >\r\n\r\nkmovw\r\nV 0F90 k K >\r\nV 0F91 K m >\r\nV 0F92 ^Rl K >\r\nV 0F93 ^K Rl >\r\n\r\nkmovd\r\nVw 66)0F90 k K >\r\nVw 66)0F91 K m >\r\nV F2)0F92 ^Rl K >\r\nV F2)0F93 ^K Rl >\r\n\r\nkmovq\r\nVw 0F90 k K >\r\nVw 0F91 K m >\r\nV F2)0F92 ^Rq K >\r\nV F2)0F93 ^K Rq >\r\n\r\nknotb:V 66)0F44 ^K K >\r\nknotw:V 0F44 ^K K >\r\nknotd:Vw 66)0F44 ^K K >\r\nknotq:Vw 0F44 ^K K >\r\n\r\nkorb:Vl 66)0F45 ^K >K K\r\nkorw:Vl 0F45 ^K >K K\r\nkord:Vlw 66)0F45 ^K >K K\r\nkorq:Vlw 0F45 ^K >K K\r\n\r\nkortestb:V 66)0F98 ^K K >\r\nkortestw:V 0F98 ^K K >\r\nkortestd:Vw 66)0F98 ^K K >\r\nkortestq:Vw 0F98 ^K K >\r\n\r\nkshiftlb:V 66)0F3A32 iB ^K K >\r\nkshiftlw:Vw 66)0F3A32 iB ^K K >\r\nkshiftld:V 66)0F3A33 iB ^K K >\r\nkshiftlq:Vw 66)0F3A33 iB ^K K >\r\n\r\nkshiftrb:V 66)0F3A30 iB ^K K >\r\nkshiftrw:Vw 66)0F3A30 iB ^K K >\r\nkshiftrd:V 66)0F3A31 iB ^K K >\r\nkshiftrq:Vw 66)0F3A31 iB ^K K >\r\n\r\n\r\nktestb:V 66)0F99 ^K K >\r\nktestw:V 0F99 ^K K >\r\nktestd:Vw 66)0F99 ^K K >\r\nktestq:Vw 0F99 ^K K >\r\n\r\nkunpckbw:Vl 66)0F4B ^K >K K\r\nkunpckdq:Vlw 0F4B ^K >K K\r\nkunpckwd:Vl 0F4B ^K >K K\r\n\r\nkxnorb:Vl 66)0F46 ^K >K K\r\nkxnorw:Vl 0F46 ^K >K K\r\nkxnord:Vlw 66)0F46 ^K >K K\r\nkxnorq:Vlw 0F46 ^K >K K\r\n\r\nkxorb:Vl 66)0F47 ^K >K K\r\nkxorw:Vl 0F47 ^K >K K\r\nkxord:Vlw 66)0F47 ^K >K K\r\nkxorq:Vlw 0F47 ^K >K K\r\n\r\nlahf:9F\r\nlar:0F02 rW Rwlq\r\nlcall/:FF.3 m\r\n\r\nlds:x C5 m Rwl\r\nlss:0FB2 m Rwl\r\nles:x C4 m Rwl\r\nlfs:0FB4 m Rwl\r\nlgs:0FB5 m Rwl\r\n\r\nlddqu:F2)0FF0 m Vxy >\r\nldmxcsr:0FAE.2 m >\r\nlea:8D m Rwlq\r\nleave:C9\r\nlfence:0FAEE8\r\nlgdt:0F01.2 m\r\nlidt:0F01.3 m\r\nljmp/:FF.5 m\r\nlldt:0F00.2 rW\r\nlmsw:0F01.6 rW\r\nlods{bwlq:AC\r\nloop:E2 jb\r\nloope:E1 jb\r\nloopne:E0 jb\r\n\r\nlret\r\nCB\r\nCA i$w\r\n\r\nlsl:0F03 rW Rwlq\r\nltr:0F00.3 rW\r\nlzcnt:F3)0FBD r Rwlq\r\n\r\nmaskmovdqu:66)0FF7 ^Vx V >\r\nmaskmovq:0FF7 ^VQ V\r\n\r\nmaxpd:66)0F5F v >V Vxyz {kzBsw\r\nmaxps:0F5F v >V Vxyz {kzbs\r\nmaxsd:F2)0F5F v >V Vx {kzsw\r\nmaxss:F3)0F5F v >V Vx {kzs\r\n\r\nmfence:0FAEF0\r\n\r\nminpd:66)0F5D v >V Vxyz {kzBsw\r\nminps:0F5D v >V Vxyz {kzbs\r\nminsd:F2)0F5D v >V Vx {kzsw\r\nminss:F3)0F5D v >V Vx {kzs\r\n\r\nmonitor:0F01C8\r\n\r\nmov\r\nX A0 %mlq R_0bwlq\r\nX A2 R_0bwlq %mlq\r\n88 Rbwlq r\r\n8A r Rbwlq\r\nX C7.0 Il Rq\r\nX C7.0 iL mq\r\nB0+8.o i Rbwlq\r\nC6.0 i rbwl\r\n8C s ^RwlQ\r\n8C s mW\r\n8E ^RWlQ s\r\n8E mW s\r\nX 0F20 C ^RQ\r\nX 0F21 D ^RQ\r\nX 0F22 ^RQ C\r\nX 0F23 ^RQ D\r\nx 0F20 C ^RL\r\nx 0F21 D ^RL\r\nx 0F22 ^RL C\r\nx 0F23 ^RL D\r\n\r\nmovabs/\r\nX A0 %mlQ R_0bwlq\r\nX A2 R_0bwlq %mlQ\r\nX B8.o i Rq\r\n\r\nmovapd\r\n66)0F28 v Vxyz > {kzw\r\n66)0F29 Vxyz v > {kzw\r\n\r\nmovaps\r\n0F28 v Vxyz > {kz\r\n0F29 Vxyz v > {kz\r\n\r\nmovbe\r\n0F38F0 m Rwlq\r\n0F38F1 Rwlq m\r\n\r\nmovd\r\n0F6E rL VQ\r\n0F7E VQ rL\r\n66)0F6E rL Vx > {\r\n66)0F7E Vx rL > {\r\n\r\nmovddup:F2)0F12 v Vxyz > {kzw\r\nmovdiri:0F38F9 Rlq m\r\nmovdir64b:66)0F38F8 m RQ\r\n\r\nmovdqa\r\n66)0F6F v Vxy >\r\n66)0F7F Vxy v >\r\n\r\nmovdqa32\r\n66)0F6F v Vxyz > {kzf\r\n66)0F7F Vxyz v > {kzf\r\n\r\nmovdqa64\r\n66)0F6F v Vxyz > {kzfw\r\n66)0F7F Vxyz v > {kzfw\r\n\r\nmovdqu\r\nF3)0F6F v Vxy >\r\nF3)0F7F Vxy v >\r\n\r\nmovdqu8\r\nF2)0F6F v Vxyz > {kzf\r\nF2)0F7F Vxyz v > {kzf\r\n\r\nmovdqu16\r\nF2)0F6F v Vxyz > {kzfw\r\nF2)0F7F Vxyz v > {kzfw\r\n\r\nmovdqu32\r\nF3)0F6F v Vxyz > {kzf\r\nF3)0F7F Vxyz v > {kzf\r\n\r\nmovdqu64\r\nF3)0F6F v Vxyz > {kzfw\r\nF3)0F7F Vxyz v > {kzfw\r\n\r\nmovdq2q:F2)0FD6 ^Vx VQ\r\nmovhlps:0F12 ^Vx >V V {\r\n\r\nmovhpd\r\n66)0F16 m >V Vx {w\r\n66)0F17 Vx m > {w\r\n\r\nmovhps\r\n0F16 m >V Vx {\r\n0F17 Vx m > {\r\n\r\nmovlhps:0F16 ^Vx >V V {\r\n\r\nmovlpd\r\n66)0F12 m >V Vx {w\r\n66)0F13 Vx m > {w\r\n\r\nmovlps\r\n0F12 m >V Vx {\r\n0F13 Vx m > {\r\n\r\nmovmskpd:66)0F50 ^Vxy R! >\r\nmovmskps:0F50 ^Vxy R! >\r\n\r\nmovntdqa:66)0F382A m Vxyz > {\r\nmovntdq:66)0FE7 Vxyz m > {\r\nmovnti:0FC3 Rlq m\r\n\r\nmovntpd:66)0F2B Vxyz m > {w\r\nmovntps:0F2B Vxyz m > {\r\n\r\nmovntq:0FE7 VQ m\r\n\r\nmovq\r\n0F6E ^R Vq\r\n0F7E Vq ^R\r\n66)0F6E ^R#q VX > {\r\n66)0F7E VX ^R#q > {\r\n0F6F vQ V\r\n0F7F VQ v\r\nF3)0F7E v Vx > {w\r\n66)0FD6 Vx v > {w\r\n\r\nmovq2dq:F3)0FD6 ^VQ Vx\r\nmovs{bwlq:A4\r\n\r\nmovsd\r\nF2)0F10 ^Vx >V V {kzw\r\nF2)0F10 m Vx > {kzw\r\nF2)0F11 Vx m > {kw\r\n\r\nmovshdup:F3)0F16 v Vxyz > {kz\r\n\r\nmovsldup:F3)0F12 v Vxy > {kz\r\n\r\nmovss\r\nF3)0F10 ^Vx >V V {kz\r\nF3)0F10 m Vx > {kz\r\nF3)0F11 Vx m > {k\r\n\r\nmovsbw/:0FBE rB Rw\r\nmovsbl/:0FBE rB Rl\r\nmovsbq/:0FBE rB Rq\r\nmovswl/:0FBF rW Rl\r\nmovswq/:0FBF rW Rq\r\nmovslq/:63 rL Rq\r\nmovsxd/:63 rL Rq\r\n/movsxd:63 rL Rwlq\r\nmovsx:0FBE rb$w Rwlq\r\n\r\nmovupd\r\n66)0F10 v Vxyz > {kzw\r\n66)0F11 Vxyz v > {kzw\r\n\r\nmovups\r\n0F10 v Vxyz > {kz\r\n0F11 Vxyz v > {kz\r\n\r\nmovzbw/:0FB6 rB Rw\r\nmovzbl/:0FB6 rB Rl\r\nmovzwl/:0FB7 rW Rl\r\nmovzx:0FB6 rb$w Rwlq\r\nmpsadbw:66)0F3A42 ib v >V Vxy\r\nmul:F6.4 rbwlq\r\n\r\nmulpd:66)0F59 v >V Vxyz {kzBrw\r\nmulps:0F59 v >V Vxyz {kzbr\r\nmulsd:F2)0F59 v >V Vx {kzrw\r\nmulss:F3)0F59 v >V Vx {kzr\r\n\r\nmulx:V F2)0F38F6 r >Rlq R\r\nmwait:0F01C9\r\n\r\nneg:F6.3 rbwlq\r\n\r\nnop\r\n90\r\n0F1F.0 rwL\r\n\r\nnot:F6.2 rbwlq\r\n\r\norpd:66)0F56 v >V Vxyz {kzBw\r\norps:0F56 v >V Vxyz {kzb\r\n\r\nout\r\nE6 R_0bwl ib\r\nEE R_0bwl R_2W\r\n\r\nouts{bwl:6E\r\n\r\npabsb:0F381C v Vqxyz > {kz\r\npabsd:0F381E v Vqxyz > {kzb\r\npabsq:66)0F381F v Vxyz > {kzBwf\r\npabsw:0F381D v Vqxyz > {kz\r\n\r\npackssdw:0F6B v >V Vqxyz {kzb\r\npacksswb:0F63 v >V Vqxyz {kz\r\npackusdw:66)0F382B v >V Vxyz {kzb\r\npackuswb:0F67 v >V Vqxyz {kz\r\n\r\npaddb:0FFC v >V Vqxyz {kz\r\npaddd:0FFE v >V Vqxyz {kbz\r\npaddq:0FD4 v >V Vqxyz {kBzw\r\npaddw:0FFD v >V Vqxyz {kz\r\n\r\npaddsb:0FEC v >V Vqxyz {kz\r\npaddsw:0FED v >V Vqxyz {kz\r\npaddusb:0FDC v >V Vqxyz {kz\r\npaddusw:0FDD v >V Vqxyz {kz\r\n\r\npalignr:0F3A0F ib v >V Vqxyz {kz\r\n\r\npand:0FDB v >V Vqxy\r\npandd:66)0FDB v >V Vxyz {kzbf\r\npandq:66)0FDB v >V Vxyz {kzBwf\r\n\r\npandn:0FDF v >V Vqxy\r\npandnd:66)0FDF v >V Vxyz {kzbf\r\npandnq:66)0FDF v >V Vxyz {kzBwf\r\n\r\npause:F3)90\r\n\r\npavgb:0FE0 v >V Vqxyz {kz\r\npavgw:0FE3 v >V Vqxyz {kz\r\n\r\npblendvb\r\n66)0F3810 V_0x v V\r\nv 66)0F3A4C <Vxy v >V V\r\n\r\npblendw:66)0F3A0E ib v >V Vxy\r\npclmulqdq:66)0F3A44 ib v >V Vxyz {\r\n\r\npcmpeqb\r\n0F74 v >V Vqxy\r\n66)0F74 v >Vxyz K {kf\r\n\r\npcmpeqd\r\n0F76 v >V Vqxy\r\n66)0F76 v >Vxyz K {kbf\r\n\r\npcmpeqw\r\n0F75 v >V Vqxy\r\n66)0F75 v >Vxyz K {kf\r\n\r\npcmpeqq\r\n66)0F3829 v >V Vxy\r\n66)0F3829 v >Vxyz K {kBwf\r\n\r\npcmpestri:66)0F3A61 ib v Vx >\r\n\r\npcmpestrm:66)0F3A60 ib v Vx >\r\n\r\npcmpgtb\r\n0F64 v >V Vqxy\r\n66)0F64 v >Vxyz K {kf\r\n\r\npcmpgtd\r\n0F66 v >V Vqxy\r\n66)0F66 v >Vxyz K {kbf\r\n\r\npcmpgtq\r\n66)0F3837 v >V Vxy\r\n66)0F3837 v >Vxyz K {kBwf\r\n\r\npcmpgtw\r\n0F65 v >V Vqxy\r\n66)0F65 v >Vxyz K {kf\r\n\r\npcmpistri:66)0F3A63 ib v Vx >\r\npcmpistrm:66)0F3A62 ib v Vx >\r\n\r\npdep:V F2)0F38F5 r >Rlq R\r\npext:V F3)0F38F5 r >Rlq R\r\n\r\npextrb:66)0F3A14 ib Vx r! > {\r\npextrd:66)0F3A16 ib Vx rL > {\r\n\r\npextrw\r\n0FC5 ib ^Vqx R! > {\r\n66)0F3A15 ib Vx m > {\r\n\r\npextrq:66)0F3A16 ib Vx r#q > {\r\n\r\nphaddw:0F3801 v >V Vqxy\r\nphaddd:0F3802 v >V Vqxy\r\nphaddsw:0F3803 v >V Vqxy\r\n\r\nphminposuw:66)0F3841 v Vx >\r\n\r\nphsubd:0F3806 v >V Vqxy\r\nphsubsw:0F3807 v >V Vqxy\r\nphsubw:0F3805 v >V Vqxy\r\n\r\npinsrb:66)0F3A20 ib rL >Vx Vx {\r\npinsrd:66)0F3A22 ib rL >Vx Vx {\r\npinsrq:66)0F3A22 ib r#q >Vx Vx {\r\npinsrw:0FC4 ib *rL >V Vqx {\r\n\r\npmaddubsw:0F3804 v >V Vqxyz {kz\r\npmaddwd:0FF5 v >V Vqxyz {kz\r\n\r\npmaxsb:66)0F383C v >V Vxyz {kz\r\npmaxsd:66)0F383D v >V Vxyz {kzb\r\npmaxsq:66)0F383D v >V Vxyz {kzBwf\r\npmaxsw:0FEE v >V Vqxyz {kz\r\n\r\npmaxub:0FDE v >V Vqxyz {kz\r\npmaxud:66)0F383F v >V Vxyz {kzb\r\npmaxuq:66)0F383F v >V Vxyz {kzBwf\r\npmaxuw:66)0F383E v >V Vxyz {kz\r\n\r\npminsb:66)0F3838 v >V Vxyz {kz\r\npminsw:0FEA v >V Vqxyz {kz\r\npminsq:66)0F3839 v >V Vxyz {kzBwf\r\npminsd:66)0F3839 v >V Vxyz {kzb\r\n\r\npminub:0FDA v >V Vqxyz {kz\r\npminud:66)0F383B v >V Vxyz {kzb\r\npminuq:66)0F383B v >V Vxyz {kzBwf\r\npminuw:66)0F383A v >V Vxyz {kz\r\n\r\npmovmskb:0FD7 ^Vqxy R! >\r\npmovsxbw:66)0F3820 v/ Vxyz > {kz\r\npmovsxbd:66)0F3821 v/4 Vxyz > {kz\r\npmovsxbq:66)0F3822 v/8 Vxyz > {kz\r\npmovsxwd:66)0F3823 v/ Vxyz > {kz\r\npmovsxwq:66)0F3824 v/4 Vxyz > {kz\r\npmovsxdq:66)0F3825 v/ Vxyz > {kz\r\n\r\npmovzxbw:66)0F3830 v/ Vxyz > {kz\r\npmovzxbd:66)0F3831 v/4 Vxyz > {kz\r\npmovzxbq:66)0F3832 v/8 Vxyz > {kz\r\npmovzxwd:66)0F3833 v/ Vxyz > {kz\r\npmovzxwq:66)0F3834 v/4 Vxyz > {kz\r\npmovzxdq:66)0F3835 v/ Vxyz > {kz\r\n\r\npmuldq:66)0F3828 v >V Vxyz {kzBw\r\n\r\npmulhrsw:0F380B v >V Vqxyz {kz\r\npmulhuw:0FE4 v >V Vqxyz {kz\r\npmulhw:0FE5 v >V Vqxyz {kz\r\n\r\npmulld:66)0F3840 v >V Vxyz {kzb\r\npmullq:66)0F3840 v >V Vxyz {kzBfw\r\npmullw:0FD5 v >V Vqxyz {kz\r\npmuludq:0FF4 v >V Vqxyz {kzBw\r\n\r\npop\r\nX 58.o RwQ\r\nx 58.o Rwl\r\nX 8F.0 mwQ\r\nx 8F.0 mwL\r\nx 07 s_0\r\nx 17 s_2\r\nx 1F s_3\r\n0FA1 s_4\r\n0FA9 s_5\r\n\r\npopa:x 61\r\npopad:#popa\r\n\r\npopcnt:F3)0FB8 r Rwlq\r\n\r\npopf:9D\r\npopfq:#popf\r\npopfw:66)9D\r\n\r\npor:0FEB v >V Vqxy\r\npord:66)0FEB v >Vxyz V {kzbf\r\nporq:66)0FEB v >Vxyz V {kzBwf\r\n\r\nprefetcht0:0F18.1 m\r\nprefetcht1:0F18.2 m\r\nprefetcht2:0F18.3 m\r\nprefetchnta:0F18.0 m\r\nprefetchw:0F0D.1 m\r\n\r\npsadbw:0FF6 v >V Vqxyz {\r\n\r\npshufb:0F3800 v >V Vqxyz {kz\r\npshufd:66)0F70 ib v Vxyz > {kzb\r\npshufhw:F3)0F70 ib v Vxyz > {kz\r\npshuflw:F2)0F70 ib v Vxyz > {kz\r\npshufw:0F70 ib v VQ\r\n\r\npsignb:0F3808 v >V Vqxy\r\npsignd:0F380A v >V Vqxy\r\npsignw:0F3809 v >V Vqxy\r\n\r\npslldq\r\n66)0F73.7 ib Vxy >V\r\n66)0F73.7 ib v >Vxyz {f\r\n\r\npslld\r\n0FF2 vQ VQ\r\n66)0FF2 *vX >V Vxyz {kz\r\n0F72.6 ib Vqxy >V\r\n66)0F72.6 ib v >Vxyz {kzbf\r\n\r\npsllq\r\n0FF3 vQ VQ\r\n66)0FF3 *vX >V Vxyz {kzw\r\n0F73.6 ib Vqxy >V\r\n66)0F73.6 ib v >Vxyz {kzBfw\r\n\r\npsllw\r\n0FF1 vQ VQ\r\n66)0FF1 *vX >V Vxyz {kz\r\n0F71.6 ib Vqxy >V\r\n66)0F71.6 ib v >Vxyz {kzf\r\n\r\npsrad\r\n0FE2 vQ VQ\r\n66)0FE2 *vX >V Vxyz {kz\r\n0F72.4 ib Vqxy >V\r\n66)0F72.4 ib v >Vxyz {kzbf\r\n\r\npsraq\r\n66)0FE2 *vX >V Vxyz {kzwf\r\n66)0F72.4 ib v >Vxyz {kzBfw\r\n\r\npsraw\r\n0FE1 vQ VQ\r\n66)0FE1 *vX >V Vxyz {kz\r\n0F71.4 ib Vqxy >V\r\n66)0F71.4 ib v >Vxyz {kzf\r\n\r\npsrldq\r\n66)0F73.3 ib Vxy >V\r\n66)0F73.3 ib v >Vxyz {f\r\n\r\npsrld\r\n0FD2 vQ VQ\r\n66)0FD2 *vX >V Vxyz {kz\r\n0F72.2 ib Vqxy >V\r\n66)0F72.2 ib v >Vxyz {kzbf\r\n\r\npsrlq\r\n0FD3 vQ VQ\r\n66)0FD3 *vX >V Vxyz {kzw\r\n0F73.2 ib Vqxy >V\r\n66)0F73.2 ib v >Vxyz {kzBfw\r\n\r\npsrlw\r\n0FD1 vQ VQ\r\n66)0FD1 *vX >V Vxyz {kz\r\n0F71.2 ib Vqxy >V\r\n66)0F71.2 ib v >Vxyz {kzf\r\n\r\npsubb:0FF8 v >V Vqxyz {kz\r\npsubd:0FFA v >V Vqxyz {kzb\r\npsubq:0FFB v >V Vqxyz {kzBw\r\npsubw:0FF9 v >V Vqxyz {kz\r\n\r\npsubsb:0FE8 v >V Vqxyz {kz\r\npsubsw:0FE9 v >V Vqxyz {kz\r\npsubusb:0FD8 v >V Vqxyz {kz\r\npsubusw:0FD9 v >V Vqxyz {kz\r\n\r\nptest:66)0F3817 v Vxy >\r\nptwrite:F3)0FAE.4 rlq\r\n\r\npunpckhbw:0F68 v >V Vqxyz {kz\r\npunpckhwd:0F69 v >V Vqxyz {kz\r\npunpckhdq:0F6A v >V Vqxyz {kzb\r\npunpckhqdq:66)0F6D v >V Vxyz {kzBw\r\n\r\npunpcklbw:0F60 v >V Vqxyz {kz\r\npunpcklwd:0F61 v >V Vqxyz {kz\r\npunpckldq:0F62 v >V Vqxyz {kzb\r\npunpcklqdq:66)0F6C v >V Vxyz {kzBw\r\n\r\npush\r\nX 50.o RwQ\r\nx 50.o Rwl\r\n6A-2 Ibl\r\nFF.6 mwQ\r\nx 06 s_0\r\nx 0E s_1\r\nx 16 s_2\r\nx 1E s_3\r\n0FA0 s_4\r\n0FA8 s_5\r\n\r\npusha:x 60\r\npushad:#pusha\r\n\r\npushf{wQ}:9C\r\npushw:66)6A-2 Ib$w\r\n\r\npxor:0FEF v >V Vqxy\r\npxord:66)0FEF v >Vxyz V {kzbf\r\npxorq:66)0FEF v >Vxyz V {kzBfw\r\n\r\nrcpps:0F53 v Vxy >\r\nrcpss:F3)0F53 v >V Vx\r\n\r\nrdfsbase:F3)0FAE.0 Rlq\r\nrdgsbase:F3)0FAE.1 Rlq\r\nrdmsr:0F32\r\nrdpid:F3)0FC7.7 RQ\r\nrdpkru:0F01EE\r\nrdpmc:0F33\r\nrdrand:0FC7.6 Rwlq\r\nrdseed:0FC7.7 Rwlq\r\nrdsspd:F3)0F1E.1 Rl\r\nrdsspq:F3)0F1E.1 Rq\r\nrdtsc:0F31\r\nrdtscp:0F01F9\r\n\r\nret\r\nC3\r\nC2 i$w\r\n\r\nrorx:V F2)0F3AF0 ib r Rlq\r\n\r\nroundpd:66)0F3A09 ib v Vxy >\r\nroundps:66)0F3A08 ib v Vxy >\r\nroundsd:66)0F3A0B ib v >V Vx\r\nroundss:66)0F3A0A ib v >V Vx\r\n\r\nrsm:0FAA\r\n\r\nrsqrtps:0F52 v Vxy >\r\nrsqrtss:F3)0F52 v >V Vx\r\n\r\nrstorssp:F3)0F01.5 m\r\n\r\nsahf:9E\r\nsal:#shl\r\nsarx:V F3)0F38F7 >Rlq r R\r\nsaveprevssp:F3)0F01EA\r\nscas{bwlq:AE\r\nsetssbsy:F3)0F01E8\r\nsfence:0FAEF8\r\nsgdt:0F01.0 m\r\nsha1rnds4:0F3ACC ib v Vx\r\nsha1nexte:0F38C8 v Vx\r\nsha1msg1:0F38C9 v Vx\r\nsha1msg2:0F38CA v Vx\r\nsha256rnds2:0F38CB V_0x v V\r\nsha256msg1:0F38CC v Vx\r\nsha256msg2:0F38CD v Vx\r\n\r\nshld\r\n0FA4 ib Rwlq r\r\n0FA5 R_1b Rwlq r\r\n\r\nshlx:V 66)0F38F7 >Rlq r R\r\n\r\nshrd\r\n0FAC ib Rwlq r\r\n0FAD R_1b Rwlq r\r\n\r\nshrx:V F2)0F38F7 >Rlq r R\r\n\r\nshufpd:66)0FC6 ib v >V Vxyz {kzBw\r\nshufps:0FC6 ib v >V Vxyz {kzb\r\n\r\nsidt:0F01.1 m\r\n\r\nsldt\r\n0F00.0 Rwl$q\r\n0F00.0 mW\r\n\r\nsmsw\r\n0F01.4 Rwlq\r\n0F01.4 mWL\r\n\r\nsqrtpd:66)0F51 v Vxyz > {kzBrw\r\nsqrtps:0F51 v Vxyz > {kzbr\r\nsqrtsd:F2)0F51 v >V Vx {kzrw\r\nsqrtss:F3)0F51 v >V Vx {kzr\r\n\r\nstac:0F01CB\r\nstc:F9\r\nstd:FD\r\nsti:FB\r\nstmxcsr:0FAE.3 m >\r\nstos{bwlq:AA\r\n\r\nstr\r\n0F00.1 RwL$q\r\n0F00.1 mW\r\n\r\nsubpd:66)0F5C v >V Vxyz {kzrBw\r\nsubps:0F5C v >V Vxyz {kzrb\r\nsubsd:F2)0F5C v >V Vx {kzrw\r\nsubss:F3)0F5C v >V Vx {kzr\r\n\r\nswapgs:X 0F01F8\r\nsyscall:X 0F05\r\nsysenter:0F34\r\nsysexit{Lq:0F35\r\nsysret{Lq:X 0F07\r\n\r\ntest\r\nA8 i R_0bwl\r\nA9 iL R_0q\r\nF6.0 i rbwl\r\nF7.0 iL rq\r\n84 Rbwlq r\r\n\r\ntpause:66)0FAE.6 Rl\r\ntzcnt:F3)0FBC r Rwlq\r\n\r\nucomisd:66)0F2E v Vx > {sw\r\nucomiss:0F2E v Vx > {s\r\n\r\nud0:0FFF rL R\r\nud1:0FB9 rL R\r\nud2:0F0B\r\n\r\numonitor\r\n67F3)0FAE.6 Rl\r\nF3)0FAE.6 RQ\r\n\r\numwait:F2)0FAE.6 Rl\r\n\r\nunpckhpd:66)0F15 v >V Vxyz {kzBw\r\nunpckhps:0F15 v >V Vxyz {kzb\r\nunpcklpd:66)0F14 v >V Vxyz {kzBw\r\nunpcklps:0F14 v >V Vxyz {kzb\r\n\r\nvalignd:66)0F3A03 ib v >Vxyz V {kzbf\r\nvalignq:66)0F3A03 ib v >Vxyz V {kzBfw\r\n\r\nvblendmpd:66)0F3865 v >V Vxyz {kzBfw\r\nvblendmps:66)0F3865 v >V Vxyz {kzbf\r\n\r\nvbroadcastss:66)0F3818 vx|l Vxyz > {kz\r\nvbroadcastsd:66)0F3819 vx|Q Vyz > {kzw\r\n\r\nvbroadcastf128:66)0F381A m Vy >\r\nvbroadcastf32x2:66)0F3819 vx|Q Vyz > {kzf\r\nvbroadcastf32x4:66)0F381A m|x Vyz > {kzf\r\nvbroadcastf64x2:66)0F381A m|x Vyz > {kzwf\r\nvbroadcastf32x8:66)0F381B m|y Vz > {kzf\r\nvbroadcastf64x4:66)0F381B m|y Vz > {kzfw\r\n\r\nvbroadcasti128:66)0F385A m Vy >\r\nvbroadcasti32x2:66)0F3859 vx|Q Vxyz > {kzf\r\nvbroadcasti32x4:66)0F385A m|x Vyz > {kzf\r\nvbroadcasti64x2:66)0F385A m|x Vyz > {kzfw\r\nvbroadcasti32x8:66)0F385B m|y Vz > {kzf\r\nvbroadcasti64x4:66)0F385B m|y Vz > {kzfw\r\n\r\nvcompresspd:66)0F388A Vxyz v > {kzwfT3\r\nvcompressps:66)0F388A Vxyz v > {kzfT2\r\n\r\nvcvtne2ps2bf16:F2)0F3872 v >V Vxyz {kzbf\r\nvcvtneps2bf16:F3)0F3872 v#xy~z V/ > {kzbf\r\n\r\nvcvtpd2qq:66)0F7B v Vxyz > {kzBwrf\r\nvcvtpd2udq:0F79 v#xy~z V/ > {kzBwrf\r\nvcvtpd2uqq:66)0F79 v Vxyz > {kzBwrf\r\nvcvtph2ps:66)0F3813 v/ Vxyz > {kzs\r\nvcvtps2ph:66)0F3A1D ib Vxyz v/ > {kzs\r\nvcvtps2udq:0F79 v Vxyz > {kzbrf\r\nvcvtps2qq:66)0F7B v/ Vxyz > {kzbrf\r\nvcvtps2uqq:66)0F79 v/ Vxyz > {kzbrf\r\nvcvtqq2pd:F3)0FE6 v Vxyz > {kzBrfw\r\nvcvtqq2ps:0F5B v#xy~z V/ > {kzBrfw\r\nvcvtsd2usi:F2)0F79 v#x Rlq > {rfT3\r\nvcvtss2usi:F3)0F79 v#x Rlq > {rfT2\r\nvcvttpd2qq:66)0F7A v Vxyz > {kzBwsf\r\nvcvttpd2udq:0F78 v#xy~z V/ > {kzBwsf\r\nvcvttpd2uqq:66)0F78 v Vxyz > {kzBwsf\r\nvcvttps2udq:0F78 v Vxyz > {kzbsf\r\nvcvttps2qq:66)0F7A v/ Vxyz > {kzbsf\r\nvcvttps2uqq:66)0F78 v/ Vxyz > {kzbsf\r\nvcvttsd2usi:F2)0F78 v#x Rlq > {sfT3\r\nvcvttss2usi:F3)0F78 v#x Rlq > {sfT2\r\nvcvtudq2pd:F3)0F7A v/ Vxyz > {kzbf\r\nvcvtudq2ps:F2)0F7A v Vxyz > {kzbrf\r\nvcvtuqq2pd:F3)0F7A v Vxyz > {kzBrfw\r\nvcvtuqq2ps:F2)0F7A v#xy~z V/ > {kzBfrw\r\nvcvtusi2sd:F2)0F7B rlq >Vx V {rfTR\r\nvcvtusi2ss:F3)0F7B rlq >Vx V {rfTR\r\n\r\nvdbpsadbw:66)0F3A42 ib v >Vxyz V {kzf\r\nvdpbf16ps:F3)0F3852 v >Vxyz V {kzf\r\n\r\nvexpandpd:66)0F3888 v Vxyz > {kzwfT3\r\nvexpandps:66)0F3888 v Vxyz > {kzfT2\r\n\r\nverr:! 0F00.4 rW\r\nverw:! 0F00.5 rW\r\n\r\nvextractf128:66)0F3A19 ib Vy vX >\r\nvextractf32x4:66)0F3A19 ib Vyz vx|x > {kzf\r\nvextractf64x2:66)0F3A19 ib Vyz vx|x > {kzfw\r\nvextractf32x8:66)0F3A1B ib Vz vy|y > {kzf\r\nvextractf64x4:66)0F3A1B ib Vz vy|y > {kzfw\r\n\r\nvextracti128:66)0F3A39 ib Vy vX >\r\nvextracti32x4:66)0F3A39 ib Vyz vx|x > {kzf\r\nvextracti64x2:66)0F3A39 ib Vyz vx|x > {kzfw\r\nvextracti32x8:66)0F3A3B ib Vz vy|y > {kzf\r\nvextracti64x4:66)0F3A3B ib Vz vy|y > {kzfw\r\n\r\nvfixupimmpd:66)0F3A54 ib v >Vxyz V {kzBsfw\r\nvfixupimmps:66)0F3A54 ib v >Vxyz V {kzbsf\r\nvfixupimmsd:66)0F3A55 ib v|Q >Vx V {kzsfw\r\nvfixupimmss:66)0F3A55 ib v|l >Vx V {kzsf\r\n\r\nvfpclasspd:66)0F3A66 iB vxyz K > {kBfw\r\nvfpclassps:66)0F3A66 iB vxyz K > {kbf\r\nvfpclasssd:66)0F3A67 ib v#x K > {kfwT3\r\nvfpclassss:66)0F3A67 ib v#x K > {kfT2\r\n\r\nvgatherdpd\r\nvw 66)0F3892 >Vxy *Gx V\r\n66)0F3892 G/ Vxyz > {Kfw\r\n\r\nvgatherdps\r\n66)0F3892 >Vxy G V\r\n66)0F3892 Gxyz V > {Kf\r\n\r\nvgatherqpd\r\nvw 66)0F3893 >Vxy G V\r\n66)0F3893 Gxyz V > {Kfw\r\n\r\nvgatherqps\r\n66)0F3893 >Vx Gxy Vx\r\n66)0F3893 Gxyz V/ > {Kf\r\n\r\nvgetexppd:66)0F3842 v Vxyz > {kzBsfw\r\nvgetexpps:66)0F3842 v Vxyz > {kzbsf\r\nvgetexpsd:66)0F3843 vx|q >Vx V > {kzsfw\r\nvgetexpss:66)0F3843 vx|l >Vx V > {kzsf\r\n\r\nvgetmantpd:66)0F3A26 ib v Vxyz > {kzBsfw\r\nvgetmantps:66)0F3A26 ib v Vxyz > {kzbsf\r\nvgetmantsd:66)0F3A27 ib vx|q >Vx V {kzsfw\r\nvgetmantss:66)0F3A27 ib vx|l >Vx V {kzsf\r\n\r\nvinsertf128:66)0F3A18 ib vX >Vy V\r\nvinsertf32x4:66)0F3A18 ib vx|x >Vyz V {kzf\r\nvinsertf64x2:66)0F3A18 ib vx|x >Vyz V {kzfw\r\nvinsertf32x8:66)0F3A1A ib vy|y >Vz V {kzf\r\nvinsertf64x4:66)0F3A1A ib vy|y >Vz V {kzfw\r\n\r\nvinserti128:66)0F3A38 ib vX >Vy V\r\nvinserti32x4:66)0F3A38 ib vx|x >Vyz V {kzf\r\nvinserti64x2:66)0F3A38 ib vx|x >Vyz V {kzfw\r\nvinserti32x8:66)0F3A3A ib vy|y >Vz V {kzf\r\nvinserti64x4:66)0F3A3A ib vy|y >Vz V {kzfw\r\n\r\nvmaskmovpd\r\n66)0F382D m >Vxy V\r\n66)0F382F Vxy >V m\r\n\r\nvmaskmovps\r\n66)0F382C m >Vxy V\r\n66)0F382E Vxy >V m\r\n\r\nvp2intersectd:F2)0F3868 v >Vxyz K {bf\r\nvp2intersectq:F2)0F3868 v >Vxyz K {Bfw\r\n\r\nvpblendd:66)0F3A02 ib v >Vxy V\r\n\r\nvpblendmb:66)0F3866 v >Vxyz V {kzf\r\nvpblendmd:66)0F3864 v >Vxyz V {kzbf\r\nvpblendmq:66)0F3864 v >Vxyz V {kzBfw\r\nvpblendmw:66)0F3866 v >Vxyz V {kzfw\r\n\r\nvpbroadcastb\r\n66)0F3878 vx|b Vxyz > {kz\r\n66)0F387A ^R! Vxyz > {kzf\r\n\r\nvpbroadcastd\r\n66)0F3858 vx|l Vxyz > {kz\r\n66)0F387C ^Rl Vxyz > {kzf\r\n\r\nvpbroadcastq\r\n66)0F3859 vx|Q Vxyz > {kzw\r\n66)0F387C ^Rq Vxyz > {kzf\r\n\r\nvpbroadcastw\r\n66)0F3879 vx|w Vxyz > {kz\r\n66)0F387B ^R! Vxyz > {kzf\r\n\r\nvpbroadcastmb2q:F3)0F382A ^K Vxyz > {wf\r\nvpbroadcastmw2d:F3)0F383A ^K Vxyz > {f\r\n\r\nvpcmpb:66)0F3A3F ib v >Vxyz K {kf\r\nvpcmpd:66)0F3A1F ib v >Vxyz K {kbf\r\nvpcmpq:66)0F3A1F ib v >Vxyz K {kBfw\r\nvpcmpw:66)0F3A3F ib v >Vxyz K {kfw\r\n\r\nvpcmpub:66)0F3A3E ib v >Vxyz K {kf\r\nvpcmpud:66)0F3A1E ib v >Vxyz K {kbf\r\nvpcmpuq:66)0F3A1E ib v >Vxyz K {kBfw\r\nvpcmpuw:66)0F3A3E ib v >Vxyz K {kfw\r\n\r\nvpcompressb\r\n66)0F3863 Vxyz ^V > {kzf\r\n66)0F3863 Vxyz m|b > {kf\r\n\r\nvpcompressw\r\n66)0F3863 Vxyz ^V > {kzfw\r\n66)0F3863 Vxyz m|w > {kfw\r\n\r\nvpcompressd:66)0F388B Vxyz v|l > {kzf\r\nvpcompressq:66)0F388B Vxyz v|Q > {kzfw\r\n\r\nvpconflictd:66)0F38C4 v Vxyz > {kzbf\r\nvpconflictq:66)0F38C4 v Vxyz > {kzBfw\r\n\r\nvpdpbusd:66)0F3850 v >Vxyz V {kzbf\r\nvpdpbusds:66)0F3851 v >Vxyz V {kzbf\r\nvpdpwssd:66)0F3852 v >Vxyz V {kzbf\r\nvpdpwssds:66)0F3853 v >Vxyz V {kzbf\r\n\r\nvperm2f128:66)0F3A06 ib v >Vy V\r\nvperm2i128:66)0F3A46 ib v >Vy V\r\n\r\nvpermb:66)0F388D v >Vxyz V {kzf\r\nvpermd:66)0F3836 v >Vyz V {kzb\r\nvpermw:66)0F388D v >Vxyz V {kzwf\r\n\r\nvpermq\r\nvw 66)0F3A00 ib v Vyz > {kzB\r\n66)0F3836 v >Vyz V {kzBfw\r\n\r\nvpermi2b:66)0F3875 v >Vxyz V {kzf\r\nvpermi2d:66)0F3876 v >Vxyz V {kzbf\r\nvpermi2q:66)0F3876 v >Vxyz V {kzBfw\r\nvpermi2w:66)0F3875 v >Vxyz V {kzfw\r\n\r\nvpermi2pd:66)0F3877 v >Vxyz V {kzBfw\r\nvpermi2ps:66)0F3877 v >Vxyz V {kzbf\r\n\r\nvpermilpd\r\n66)0F380D v >Vxyz V {kzBw\r\n66)0F3A05 ib v Vxyz > {kzBw\r\n\r\nvpermilps\r\n66)0F380C v >Vxyz V {kzb\r\n66)0F3A04 ib v Vxyz > {kzb\r\n\r\nvpermpd\r\nvw 66)0F3A01 ib v Vyz > {kzB\r\n66)0F3816 v >Vyz V {kzBwf\r\n\r\nvpermps:66)0F3816 v >Vyz V {kzb\r\n\r\nvpermt2b:66)0F387D v >Vxyz V {kzf\r\nvpermt2d:66)0F387E v >Vxyz V {kzbf\r\nvpermt2q:66)0F387E v >Vxyz V {kzBfw\r\nvpermt2w:66)0F387D v >Vxyz V {kzfw\r\n\r\nvpermt2pd:66)0F387F v >Vxyz V {kzBfw\r\nvpermt2ps:66)0F387F v >Vxyz V {kzbf\r\n\r\nvpexpandb:66)0F3862 v|b Vxyz > {kzf\r\nvpexpandd:66)0F3889 v|l Vxyz > {kzf\r\nvpexpandq:66)0F3889 v|Q Vxyz > {kzfw\r\nvpexpandw:66)0F3862 v|w Vxyz > {kzfw\r\n\r\nvpgatherdd\r\n66)0F3890 >Vxy G V\r\n66)0F3890 Gxyz V > {Kf\r\n\r\nvpgatherdq\r\nvw 66)0F3890 >Vxy *Gx V\r\n66)0F3890 G/ Vxyz > {Kfw\r\n\r\nvpgatherqd\r\n66)0F3891 >Vx *Gxy V\r\n66)0F3891 Gxyz V/ > {Kf\r\n\r\nvpgatherqq\r\nvw 66)0F3891 >Vxy G V\r\n66)0F3891 Gxyz V > {Kfw\r\n\r\nvplzcntd:66)0F3844 v Vxyz > {kzbf\r\nvplzcntq:66)0F3844 v Vxyz > {kzBwf\r\n\r\nvpmadd52huq:66)0F38B5 v >Vxyz V {kzBwf\r\nvpmadd52luq:66)0F38B4 v >Vxyz V {kzBwf\r\n\r\nvpmaskmovd\r\n66)0F388C m >Vxy V\r\n66)0F388E Vxy >V m\r\n\r\nvpmaskmovq\r\nvw 66)0F388C m >Vxy V\r\nvw 66)0F388E Vxy >V m\r\n\r\nvpmovb2m:F3)0F3829 ^Vxyz K > {f\r\nvpmovd2m:F3)0F3839 ^Vxyz K > {f\r\nvpmovq2m:F3)0F3839 ^Vxyz K > {fw\r\nvpmovw2m:F3)0F3829 ^Vxyz K > {fw\r\n\r\nvpmovdb:F3)0F3831 Vxyz v/4 > {kzf\r\nvpmovdw:F3)0F3833 Vxyz v/ > {kzf\r\nvpmovqb:F3)0F3832 Vxyz v/8 > {kzf\r\nvpmovqd:F3)0F3835 Vxyz v/ > {kzf\r\nvpmovqw:F3)0F3834 Vxyz v/4 > {kzf\r\nvpmovwb:F3)0F3830 Vxyz v/ > {kzf\r\n\r\nvpmovsdb:F3)0F3821 Vxyz v/4 > {kzf\r\nvpmovsdw:F3)0F3823 Vxyz v/ > {kzf\r\nvpmovsqb:F3)0F3822 Vxyz v/8 > {kzf\r\nvpmovsqd:F3)0F3825 Vxyz v/ > {kzf\r\nvpmovsqw:F3)0F3824 Vxyz v/4 > {kzf\r\nvpmovswb:F3)0F3820 Vxyz v/ > {kzf\r\n\r\nvpmovusdb:F3)0F3811 Vxyz v/4 > {kzf\r\nvpmovusdw:F3)0F3813 Vxyz v/ > {kzf\r\nvpmovusqb:F3)0F3812 Vxyz v/8 > {kzf\r\nvpmovusqd:F3)0F3815 Vxyz v/ > {kzf\r\nvpmovusqw:F3)0F3814 Vxyz v/4 > {kzf\r\nvpmovuswb:F3)0F3810 Vxyz v/ > {kzf\r\n\r\nvpmovm2b:F3)0F3828 ^K Vxyz > {f\r\nvpmovm2d:F3)0F3838 ^K Vxyz > {f\r\nvpmovm2q:F3)0F3838 ^K Vxyz > {fw\r\nvpmovm2w:F3)0F3828 ^K Vxyz > {fw\r\n\r\nvpmultishiftqb:66)0F3883 v >Vxyz V {kzBfw\r\n\r\nvpopcntb:66)0F3854 v Vxyz > {kzf\r\nvpopcntd:66)0F3855 v Vxyz > {kzbf\r\nvpopcntw:66)0F3854 v Vxyz > {kzfw\r\nvpopcntq:66)0F3855 v Vxyz > {kzBfw\r\n\r\nvprold:66)0F72.1 ib v >Vxyz {kzbf\r\nvprolq:66)0F72.1 ib v >Vxyz {kzBfw\r\n\r\nvprolvd:66)0F3815 v >Vxyz V {kzbf\r\nvprolvq:66)0F3815 v >Vxyz V {kzBfw\r\n\r\nvprord:66)0F72.0 ib v >Vxyz {kzbf\r\nvprorq:66)0F72.0 ib v >Vxyz {kzBfw\r\n\r\nvprorvd:66)0F3814 v >Vxyz V {kzbf\r\nvprorvq:66)0F3814 v >Vxyz V {kzBfw\r\n\r\nvpscatterdd:66)0F38A0 Vxyz G > {Kf\r\nvpscatterdq:66)0F38A0 Vxyz G/ > {Kfw\r\nvpscatterqd:66)0F38A1 V/ Gxyz > {Kf\r\nvpscatterqq:66)0F38A1 Vxyz G > {Kfw\r\n\r\nvpshldd:66)0F3A71 ib v >Vxyz V {kzbf\r\nvpshldq:66)0F3A71 ib v >Vxyz V {kzBfw\r\nvpshldw:66)0F3A70 ib v >Vxyz V {kzfw\r\n\r\nvpshldvd:66)0F3871 v >Vxyz V {kzbf\r\nvpshldvq:66)0F3871 v >Vxyz V {kzBfw\r\nvpshldvw:66)0F3870 v >Vxyz V {kzfw\r\n\r\nvpshrdd:66)0F3A73 ib v >Vxyz V {kzbf\r\nvpshrdq:66)0F3A73 ib v >Vxyz V {kzBfw\r\nvpshrdw:66)0F3A72 ib v >Vxyz V {kzfw\r\n\r\nvpshrdvd:66)0F3873 v >Vxyz V {kzbf\r\nvpshrdvq:66)0F3873 v >Vxyz V {kzBfw\r\nvpshrdvw:66)0F3872 v >Vxyz V {kzfw\r\n\r\nvpshufbitqmb:66)0F388F v >Vxyz K {kf\r\n\r\nvpsllvd:66)0F3847 v >Vxyz V {kzb\r\nvpsllvq:vw 66)0F3847 v >Vxyz V {kzB\r\nvpsllvw:66)0F3812 v >Vxyz V {kzfw\r\n\r\nvpsravd:66)0F3846 v >Vxyz V {kzb\r\nvpsravq:66)0F3846 v >Vxyz V {kzBfw\r\nvpsravw:66)0F3811 v >Vxyz V {kzfw\r\n\r\nvpsrlvd:66)0F3845 v >Vxyz V {kzb\r\nvpsrlvq:vw 66)0F3845 v >Vxyz V {kzB\r\nvpsrlvw:66)0F3810 v >Vxyz V {kzfw\r\n\r\nvpternlogd:66)0F3A25 ib v >Vxyz V {kzbf\r\nvpternlogq:66)0F3A25 ib v >Vxyz V {kzBfw\r\n\r\nvptestmb:66)0F3826 v >Vxyz K {kf\r\nvptestmd:66)0F3827 v >Vxyz K {kbf\r\nvptestmq:66)0F3827 v >Vxyz K {kBfw\r\nvptestmw:66)0F3826 v >Vxyz K {kfw\r\n\r\nvptestnmb:F3)0F3826 v >Vxyz K {kf\r\nvptestnmd:F3)0F3827 v >Vxyz K {kbf\r\nvptestnmq:F3)0F3827 v >Vxyz K {kBfw\r\nvptestnmw:F3)0F3826 v >Vxyz K {kfw\r\n\r\nvrangepd:66)0F3A50 ib v >Vxyz V {kzBsfw\r\nvrangeps:66)0F3A50 ib v >Vxyz V {kzbsf\r\nvrangesd:66)0F3A51 ib v|Q >Vx V {kzsfw\r\nvrangess:66)0F3A51 ib v|l >Vx V {kzsf\r\n\r\nvrcp14pd:66)0F384C v Vxyz > {kzBfw\r\nvrcp14ps:66)0F384C v Vxyz > {kzbf\r\nvrcp14sd:66)0F384D v|Q >Vx V {kzfw\r\nvrcp14ss:66)0F384D v|l >Vx V {kzf\r\n\r\nvreducepd:66)0F3A56 ib v Vxyz > {kzBsfw\r\nvreduceps:66)0F3A56 ib v Vxyz > {kzbsf\r\nvreducesd:66)0F3A57 ib v|Q >Vx V {kzsfw\r\nvreducess:66)0F3A57 ib v|l >Vx V {kzsf\r\n\r\nvrndscalepd:66)0F3A09 ib v Vxyz > {kzBsfw\r\nvrndscaleps:66)0F3A08 ib v Vxyz > {kzbsf\r\nvrndscalesd:66)0F3A0B ib v|Q >Vx V {kzsfw\r\nvrndscaless:66)0F3A0A ib v|l >Vx V {kzsf\r\n\r\nvrsqrt14pd:66)0F384E v Vxyz > {kzBfw\r\nvrsqrt14ps:66)0F384E v Vxyz > {kzbf\r\nvrsqrt14sd:66)0F384F v|Q >Vx V {kzfw\r\nvrsqrt14ss:66)0F384F v|l >Vx V {kzf\r\n\r\nvscalefpd:66)0F382C v >Vxyz V {kzBrfw\r\nvscalefps:66)0F382C v >Vxyz V {kzbrf\r\nvscalefsd:66)0F382D v|Q >Vx V {kzrfw\r\nvscalefss:66)0F382D v|l >Vx V {kzrf\r\n\r\nvscatterdpd:66)0F38A2 Vxyz G/ > {Kfw\r\nvscatterdps:66)0F38A2 Vxyz G > {Kf\r\nvscatterqpd:66)0F38A3 Vxyz G > {Kfw\r\nvscatterqps:66)0F38A3 V/ Gxyz > {Kf\r\n\r\nvshuff32x4:66)0F3A23 ib v >Vyz V {kzbf\r\nvshuff64x2:66)0F3A23 ib v >Vyz V {kzBfw\r\n\r\nvshufi32x4:66)0F3A43 ib v >Vyz V {kzbf\r\nvshufi64x2:66)0F3A43 ib v >Vyz V {kzBfw\r\n\r\nvtestpd:66)0F380F v Vxy >\r\nvtestps:66)0F380E v Vxy >\r\n\r\nvzeroall:vl 0F77 >\r\nvzeroupper:0F77 >\r\n\r\nwait:9B\r\nwbinvd:0F09\r\nwbnoinvd:F3)0F09\r\nwrfsbase:F3)0FAE.2 Rlq\r\nwrgsbase:F3)0FAE.3 Rlq\r\nwrmsr:0F30\r\nwrpkru:0F01EF\r\nwrssd:0F38F6 Rl m\r\nwrssq:0F38F6 Rq m\r\nwrussd:66)0F38F5 Rl m\r\nwrussq:66)0F38F5 Rq m\r\nxabort:C6F8 ib\r\nxadd:0FC0 Rbwlq r\r\nxbegin:C7F8 jl\r\n\r\nxchg\r\n90 R_0Q R_0\r\n87C0 R_0l R_0\r\n90.o R_0wlq R\r\n90.o Rwlq R_0\r\n86 Rbwlq r\r\n86 r Rbwlq\r\n\r\nxend:0F01D5\r\nxgetbv:0F01D0\r\nxlat:D7\r\n\r\nxorpd:66)0F57 v >V Vxyz {kzBw\r\nxorps:0F57 v >V Vxyz {kzb\r\n\r\nxrstor:0FAE.5 m\r\nxrstor64:X 0FAE.5 m#q\r\nxrstors:0FC7.3 m\r\nxrstors64:X 0FC7.3 m#q\r\nxsave:0FAE.4 m\r\nxsave64:X 0FAE.4 m#q\r\nxsavec:0FC7.4 m\r\nxsavec64:X 0FC7.4 m#q\r\nxsaveopt:0FAE.6 m\r\nxsaveopt64:0FAE.6 m#q\r\nxsaves:0FC7.5 m\r\nxsaves64:X 0FC7.5 m#q\r\nxsetbv:0F01D1\r\nxtest:0F01D6\r\n`;", "import { Operation } from \"./operations.js\"; // For proper JSDoc\r\nimport { floatIntSuffixes, floatSuffixes, suffixes } from \"./operands.js\";\r\nimport mnemonicList from \"./mnemonicList.js\";\r\nimport { currBitness } from \"./compiler.js\";\r\n\r\nlet lines;\r\n\r\nvar relativeMnemonics = [];\r\n\r\n/** Mnemonic set (loaded from mnemonicList.js)\r\n* @type {Object.<string,(string[]|Operation[])} */\r\nvar mnemonics = {};\r\nvar intelDifferences = {}, intelInvalids = [], attInvalids = [];\r\nmnemonicList.match(/.*:.*(?=\\n)|.[^]*?(?=\\n\\n)/g).forEach(x => {\r\n    lines = x.split(/[\\n:]/);\r\n    let name = lines.shift();\r\n    if(name.includes('{'))\r\n    {\r\n        let suffixes;\r\n        [name, suffixes] = name.split('{');\r\n        let opcode = parseInt(lines[0].match(/[0-9a-f]+/i)[0], 16);\r\n        let higherOpcode = (opcode + (suffixes.includes('b') ? 1 : 0)).toString(16);\r\n        for(let suffix of suffixes)\r\n        {\r\n            let fullName = name + suffix.toLowerCase();\r\n            if(suffix <= 'Z')\r\n            {\r\n                mnemonics[name] = lines;\r\n                mnemonics[fullName] = ['#' + name];\r\n            }\r\n            else\r\n            {\r\n                switch(suffix.toLowerCase())\r\n                {\r\n                    case 'b':\r\n                        mnemonics[fullName] = lines;\r\n                        break;\r\n                    \r\n                    case 'w':\r\n                        mnemonics[fullName] = ['66)' + higherOpcode];\r\n                        break;\r\n                    \r\n                    case 'l':\r\n                        mnemonics[fullName] = [higherOpcode];\r\n                        intelDifferences[name + 'd'] = [higherOpcode];\r\n                        intelInvalids.push(fullName);\r\n                        break;\r\n\r\n                    case 'q':\r\n                        mnemonics[fullName] = ['X 48)' + higherOpcode];\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if(name.includes('/'))\r\n        {\r\n            let intelName;\r\n            [name, intelName] = name.split('/');\r\n            if(name)\r\n            {\r\n                if(intelName)\r\n                    intelDifferences[intelName] = lines;\r\n                intelInvalids.push(name);\r\n            }\r\n            else\r\n            {\r\n                name = intelName;\r\n                if(intelInvalids.includes(name)) // Super special case, but we'll handle it\r\n                {\r\n                    intelInvalids.splice(intelInvalids.indexOf(name), 1);\r\n                    intelDifferences[name] = lines;\r\n                    return;\r\n                }\r\n                attInvalids.push(name);\r\n            }\r\n        }\r\n        mnemonics[name] = lines;\r\n        if(lines[0].includes('j'))\r\n            relativeMnemonics.push(name);\r\n    }\r\n});\r\n\r\n\r\nlet hex = num => num.toString(16);\r\n\r\n// Some extra mnemonics (these are easier to encode programatically as they're quite repetitive)\r\nlet arithmeticMnemonics = \"add or adc sbb and sub xor cmp\".split(' ');\r\narithmeticMnemonics.forEach((name, i) => {\r\n    let opBase = i * 8;\r\n    mnemonics[name] = [\r\n        hex(opBase + 4) + \" i R_0bw\",\r\n        \"83.\" + i + \" Ib rwlq\",\r\n        hex(opBase + 5) + \" iL R_0l\",\r\n        \"80.\" + i + \" i rbwl\",\r\n        hex(opBase + 5) + \" iL R_0q\",\r\n        \"81.\" + i + \" IL rq\",\r\n        hex(opBase) + \" Rbwlq r\",\r\n        hex(opBase + 2) + \" r Rbwlq\"\r\n    ];\r\n});\r\n\r\n// Shift mnemonics\r\nlet shiftMnemonics = `rol ror rcl rcr shl shr  sar`.split(' ');\r\nshiftMnemonics.forEach((name, i) => {\r\n    if(name)\r\n        mnemonics[name] = [\r\n            \"D0.\" + i + \" rbwlq\",\r\n            \"D0.\" + i + \" i_1B rbwlq\",\r\n            \"D2.\" + i + \" R_1b rbwlq\",\r\n            \"C0.\" + i + \" iB rbwlq\"\r\n        ];\r\n});\r\n\r\n// Adding conditional instructions\r\nlet conditionals = `o\r\nno\r\nb c nae\r\nae nb nc\r\ne z\r\nne nz\r\nbe na\r\na nbe\r\ns\r\nns\r\np pe\r\nnp po\r\nl nge\r\nge nl\r\nle ng\r\ng nle`.split('\\n');\r\nconditionals.forEach((names, i) => {\r\n    names = names.split(' ');\r\n    let firstName = names.shift();\r\n\r\n    // jxx instructions\r\n    mnemonics['j' + firstName] = [hex(0x70 + i) + \"+3856 jbl\"];\r\n    mnemonics['j' + firstName + 'w'] = ['x ' + hex(0x70 + i + 3856) + ' jw'];\r\n    relativeMnemonics.push('j' + firstName);\r\n    relativeMnemonics.push('j' + firstName + 'w');\r\n\r\n    // cmovxx instructions\r\n    mnemonics['cmov' + firstName] = [hex(0x0F40 + i) + \" r Rwlq\"];\r\n\r\n    // setxx instructions\r\n    mnemonics['set' + firstName] = [hex(0x0F90 + i) + \".0 rB\"]\r\n\r\n    // Aliases\r\n    names.forEach(name => {\r\n        mnemonics['j' + name] = ['#j' + firstName];\r\n        mnemonics['j' + name + 'w'] = ['#j' + firstName + 'w'];\r\n        relativeMnemonics.push('j' + name);\r\n        relativeMnemonics.push('j' + name + 'w');\r\n        mnemonics['cmov' + name] = ['#cmov' + firstName];\r\n        mnemonics['set' + name] = [\"#set\" + firstName]\r\n    });\r\n});\r\n\r\n// FPU arithmetics\r\nlet fpuArithMnemonics = \"add mul com comp sub subr div divr\";\r\nfpuArithMnemonics.split(' ').forEach((name, i) => {\r\n    let list = [\"D8.\" + i + \" ml\", \"DC.\" + i + \" m$q\"];\r\n    mnemonics['fi' + name] = [\"DA.\" + i + \" ml\", \"DE.\" + i + \" m$w\"];\r\n\r\n    if(i == 2 || i == 3) list.push(\"D8.\" + i + \" F\", hex(0xD8C1 + i * 8));\r\n    else\r\n    {\r\n        list.push(\"D8.\" + i + \" F F_0\");\r\n        list.push(\"DC.\" + i + \" F_0 F\");\r\n        mnemonics['f' + name + 'p'] = [\"DE.\" + i + \" F_0 F\", hex(0xDEC1 + i * 8)];\r\n    }\r\n\r\n    mnemonics['f' + name] = list;\r\n});\r\n\r\n// VFM (Vector fused multiply (-add)) instructions\r\nlet vfmOps = [\"add\", \"sub\"];\r\nlet vfmDirs = [\"132\", \"213\", \"231\"];\r\nlet vfmTypes = [\"pd\", \"ps\", \"sd\", \"ss\"];\r\nlet vfmPrefs = [\"vfm\", \"vfnm\"];\r\n\r\nvfmDirs.forEach((dir, dirI) => vfmOps.forEach((op, opI) => vfmTypes.forEach((type, typeI) =>\r\n{\r\n    vfmPrefs.forEach((pref, prefI) => \r\n        mnemonics[pref + op + dir + type] = [\r\n            (typeI % 2 ? \"\" : \"vw \") + \"66)\" +\r\n                hex(0x0F3898 + 0x10 * dirI + 4 * prefI + 2 * opI + (typeI >> 1))\r\n                + \" v >Vx\" + (typeI < 2 ? \"yz\" : \"\") + \" V {kzr\" + ['B', 'b', '', ''][typeI]\r\n        ]);\r\n    if(typeI < 2)\r\n    {\r\n        mnemonics[\"vfm\" + op + vfmOps[1 - opI] + dir + type] = [\r\n            (typeI % 2 ? \"\" : \"vw \") + \"66)\" +\r\n                hex(0x0F3896 + 0x10 * dirI + opI) + \" v >Vxyz V {kzr\" + \"Bb\"[typeI]\r\n        ];\r\n    }\r\n})));\r\n\r\nfunction isMnemonic(mnemonic, intel)\r\n{\r\n    if(mnemonics.hasOwnProperty(mnemonic))\r\n        return !(intel ? intelInvalids : attInvalids).includes(mnemonic);\r\n\r\n    return intel && intelDifferences.hasOwnProperty(mnemonic);\r\n}\r\n\r\n/**\r\n * This represents a particular interpretation of a\r\n * mnemonic, containing a list of operations\r\n */\r\nexport class MnemonicInterpretation\r\n{\r\n    /** \r\n     * Constructor\r\n     * @param {string} raw\r\n     * @param {Operation[]} operations\r\n     * @param {Number | null | undefined} size\r\n     * @param {boolean} isVex\r\n     */\r\n    constructor(raw, operations, size, isVex)\r\n    {\r\n        this.raw = raw;\r\n        this.operations = operations;\r\n        this.relative = relativeMnemonics.includes(raw);\r\n        this.size = size;\r\n        this.vex = isVex && !operations[0].actuallyNotVex || operations[0].forceVex;\r\n    }\r\n}\r\n\r\nfunction addMnemonicInterpretation(list, raw, intel, size, isVex, bitness)\r\n{\r\n    if(!isMnemonic(raw, intel))\r\n        return;\r\n    const operations = getOperations(raw, intel).filter(x =>\r\n        (isVex ?\r\n            (x.allowVex || x.actuallyNotVex) && !x.forceVex\r\n        :\r\n            !x.vexOnly\r\n        ) && (\r\n            x.requireBitness === null ||\r\n            x.requireBitness === bitness\r\n        )\r\n    );\r\n    if(operations.length == 0)\r\n        return;\r\n    list.push(new MnemonicInterpretation(raw, operations, size, isVex));\r\n}\r\n\r\n/**\r\n * Get all possible interpretations of a mnemonic.\r\n * \r\n * This will usually consist of a single item, although in some\r\n * cases 2 or more interpretations can coexist.\r\n * \r\n * For example: \"cmpsd\" - is both \"cmps\" (compare string) with\r\n * the \"d\" (dword) suffix, but it can also be the \"cmpsd\" (compare\r\n * scalar double-precision) instruction.\r\n * @param {string} mnemonic\r\n * @param {boolean} intel\r\n * @param {boolean} expectSuffix\r\n * @param {32 | 64} bitness\r\n * @returns {MnemonicInterpretation[]}\r\n */\r\nexport function fetchMnemonic(mnemonic, intel, expectSuffix = !intel, bitness = currBitness)\r\n{\r\n    mnemonic = mnemonic.toLowerCase();\r\n    if(mnemonic.startsWith('vv'))\r\n        return [];\r\n\r\n    let isVex = mnemonic[0] == 'v';\r\n    let possibleOpcodes = isVex ? [mnemonic, mnemonic.slice(1)] : [mnemonic];\r\n    let interps = [];\r\n\r\n    for(const raw of possibleOpcodes)\r\n    {\r\n        addMnemonicInterpretation(interps, raw, intel, undefined, isVex, bitness);\r\n\r\n        // Size suffix interpretation\r\n        if(expectSuffix)\r\n        {\r\n            const suffixArray = (\r\n                raw[0] == 'f' ?\r\n                    raw[1] == 'i' ?\r\n                        floatIntSuffixes\r\n                    :\r\n                        floatSuffixes\r\n                :\r\n                    suffixes\r\n            );\r\n            const suffixLetter = raw[raw.length - 1];\r\n            let size = suffixArray[suffixLetter];\r\n            if(bitness == 32 && suffixLetter == 'q')\r\n                size = null;\r\n            addMnemonicInterpretation(\r\n                interps,\r\n                raw.slice(0, -1),\r\n                intel,\r\n                size,\r\n                isVex,\r\n                bitness\r\n            );\r\n        }\r\n    }\r\n\r\n    return interps;\r\n}\r\n\r\n/** @returns { Operation[] } */\r\nfunction getOperations(opcode, intel)\r\n{\r\n    if(intel)\r\n    {\r\n        if(intelDifferences.hasOwnProperty(opcode))\r\n        {\r\n            // For situations such as cmpsd having two different interpretations in Intel syntax\r\n            if(mnemonics.hasOwnProperty(opcode))\r\n                return [...extractMnemonic(intelDifferences, opcode), ...getOperations(opcode, false)];\r\n\r\n            return extractMnemonic(intelDifferences, opcode);\r\n        }\r\n        else if(intelInvalids.includes(opcode))\r\n            return [];\r\n    }\r\n    else if(attInvalids.includes(opcode))\r\n        return [];\r\n    if(!mnemonics.hasOwnProperty(opcode))\r\n        return [];\r\n\r\n    return extractMnemonic(mnemonics, opcode);\r\n}\r\n\r\n/**\r\n * Get a list of all registered mnemonic names\r\n * @returns {string[]}\r\n */\r\nexport function getMnemonicList()\r\n{\r\n    return Object.keys(mnemonics);\r\n}\r\n\r\nfunction extractMnemonic(database, opcode)\r\n{\r\n    let operations = database[opcode];\r\n    if(typeof operations[0] == \"string\") // If the mnemonic hasn't been decoded yet, decode it\r\n    {\r\n        if(operations[0][0] == '#') // References other mnemonic\r\n            return database[opcode] = extractMnemonic(database, operations[0].slice(1));\r\n        return database[opcode] = operations.map(line => new Operation(line.split(' ')));\r\n    }\r\n\r\n    return operations;\r\n}", "const MAX_INSTR_SIZE = 15; // Instructions are guaranteed to be at most 15 bytes\r\n\r\nimport { Operand, parseRegister, OPT, regParsePos, sizeHints, isSizeHint, PrefixEnum } from \"./operands.js\";\r\nimport { ASMError, token, next, ungetToken, setToken, currRange, Range, RelativeRange } from \"./parser.js\";\r\nimport { fetchMnemonic, MnemonicInterpretation } from \"./mnemonics.js\";\r\nimport { queueRecomp } from \"./symbols.js\";\r\nimport { Statement } from \"./statement.js\";\r\nimport { pseudoSections } from \"./sections.js\";\r\nimport { IdentifierValue } from \"./shuntingYard.js\";\r\nimport { currBitness } from \"./compiler.js\";\r\n\r\nexport const prefixes = Object.freeze({\r\n    lock: 'LOCK',\r\n    repne: 'REPNE',\r\n    repnz: 'REPNE',\r\n    rep: 'REPE',\r\n    repe: 'REPE',\r\n    repz: 'REPE',\r\n    data16: 'DATASIZE',\r\n    addr32: 'ADDRSIZE',\r\n    evex: 'EVEX'\r\n});\r\n\r\nconst SHORT_DISP = 48;\r\n\r\n/* Parse an optional \"pseudo-operand\" for rounding semantics may appear\r\nat the start or end of the operand list, depending on the syntax */\r\nfunction parseRoundingMode(vexInfo)\r\n{\r\n    let roundingName = \"\", roundStart = currRange;\r\n    vexInfo.evex = true;\r\n\r\n    while(next() != '}')\r\n    {\r\n        if(token == '\\n')\r\n            throw new ASMError(\"Expected '}'\");\r\n        roundingName += token;\r\n    }\r\n\r\n    vexInfo.round = [\"sae\", \"rn-sae\", \"rd-sae\", \"ru-sae\", \"rz-sae\"].indexOf(roundingName);\r\n    vexInfo.roundingPos = new Range(roundStart.start, currRange.end - roundStart.start);\r\n    if(vexInfo.round < 0)\r\n        throw new ASMError(\"Invalid rounding mode\", vexInfo.roundingPos);\r\n}\r\n\r\n/** Find the correct error to throw when no interpretations fit the given operand list\r\n * @param {MnemonicInterpretation[]} interps\r\n * @param {Operand[]} operands */\r\nfunction explainNoMatch(interps, operands, vexInfo)\r\n{\r\n    let minOperandCount = Infinity, maxOperandCount = 0;\r\n    let firstOrderPossible = false, secondOrderPossible = false;\r\n    let requiresMask = false;\r\n\r\n    for(const interp of interps)\r\n        for(const operation of interp.operations)\r\n        {\r\n            let opCount = (interp.vex ? operation.vexOpCatchers : operation.opCatchers).length;\r\n            if(opCount > maxOperandCount)\r\n                maxOperandCount = opCount;\r\n            if(opCount < minOperandCount)\r\n                minOperandCount = opCount;\r\n            if(opCount == operands.length && operation.requireMask)\r\n                requiresMask = true;\r\n\r\n            vexInfo.needed = interp.vex;\r\n            firstOrderPossible = firstOrderPossible || operation.matchTypes(operands, vexInfo);\r\n            operands.reverse();\r\n            secondOrderPossible = secondOrderPossible || operation.matchTypes(operands, vexInfo);\r\n            operands.reverse();\r\n        }\r\n\r\n    if(operands.length < minOperandCount)\r\n        return \"Not enough operands\";\r\n    \r\n    if(operands.length > maxOperandCount)\r\n        return \"Too many operands\";\r\n    \r\n    if(!firstOrderPossible && secondOrderPossible)\r\n        return \"Wrong operand order\";\r\n    \r\n    if(vexInfo.mask == 0 && requiresMask)\r\n        return \"Must use a mask for this instruction\";\r\n\r\n    return \"Wrong operand type\" + (operands.length == 1 ? '' : 's');\r\n}\r\n\r\n\r\nexport class Instruction extends Statement\r\n{\r\n    constructor({ name, ...config })\r\n    {\r\n        super({ ...config, maxSize: MAX_INSTR_SIZE });\r\n        this.opcode = name.toLowerCase();\r\n        this.opcodeRange = new RelativeRange(config.range, config.range.start, config.range.length);\r\n\r\n        this.interpret();\r\n    }\r\n\r\n    // Generate Instruction.outline\r\n    interpret()\r\n    {\r\n        let opcode = this.opcode, operand = null, evexPrefixRange;\r\n        let vexInfo = {\r\n            needed: false,\r\n            evex: false,\r\n            mask: 0,\r\n            zeroing: false,\r\n            round: null,\r\n            broadcast: null\r\n        };\r\n\r\n        /** @type {Operand?} */\r\n        let memoryOperand = null;\r\n        this.needsRecompilation = false;\r\n\r\n        /** @type { Operand[] } */\r\n        let operands = [];\r\n\r\n        this.prefsToGen = new PrefixEnum();\r\n\r\n        while(prefixes.hasOwnProperty(opcode)) // Prefix\r\n        {\r\n            this.prefsToGen[prefixes[opcode]] = true;\r\n            if(opcode == 'evex')\r\n                evexPrefixRange = this.opcodeRange;\r\n\r\n            this.opcodeRange = new RelativeRange(this.range, currRange.start, currRange.length);\r\n            opcode = token.toLowerCase();\r\n            if(opcode === ';' || opcode === '\\n')\r\n                throw new ASMError(\"Expected opcode\", this.opcodeRange);\r\n            next();\r\n        }\r\n        this.opcode = opcode;\r\n\r\n        let interps = fetchMnemonic(opcode, this.syntax.intel);\r\n        if(interps.length == 0)\r\n            throw new ASMError(\"Unknown opcode\", this.opcodeRange);\r\n        \r\n        interps = interps.filter(interp => interp.size !== null);\r\n        if(interps.length == 0)\r\n            throw new ASMError(\"Invalid opcode suffix\",\r\n                new RelativeRange(this.range, this.opcodeRange.end - 1, 1)\r\n            );\r\n        if(this.prefsToGen.EVEX)\r\n        {\r\n            interps = interps.filter(interp => interp.operations.some(op => op.evexPermits !== null));\r\n            if(interps.length == 0)\r\n                throw new ASMError(\"No EVEX encoding exists for this instruction\", evexPrefixRange);\r\n        }\r\n        \r\n        const expectRelative = interps.some(interp => interp.relative);\r\n\r\n        if(!this.syntax.intel && token == '{')\r\n        {\r\n            parseRoundingMode(vexInfo);\r\n            if(next() != ',')\r\n                throw new ASMError(\"Expected ','\");\r\n            next();\r\n        }\r\n\r\n        // Collecting the operands\r\n        while(token != ';' && token != '\\n')\r\n        {\r\n            let sizePtrRange = currRange, enforcedSize = null;\r\n            if(this.syntax.intel)\r\n            {\r\n                if(token == '{')\r\n                {\r\n                    parseRoundingMode(vexInfo);\r\n                    next();\r\n                    break;\r\n                }\r\n                let sizePtr = token;\r\n                if(isSizeHint(sizePtr.toLowerCase()))\r\n                {\r\n                    let following = next();\r\n                    if(following.toLowerCase() == 'ptr')\r\n                    {\r\n                        sizePtrRange = sizePtrRange.until(currRange);\r\n                        enforcedSize = sizeHints[sizePtr.toLowerCase()];\r\n                        if(\",;\\n{:\".includes(next()))\r\n                        {\r\n                            ungetToken();\r\n                            setToken(following);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        if(\",;\\n{:\".includes(following)) // It's just a symbol\r\n                        {\r\n                            ungetToken();\r\n                            setToken(sizePtr);\r\n                        }\r\n                        else\r\n                            enforcedSize = sizeHints[sizePtr.toLowerCase()];\r\n                    }\r\n                }\r\n            }\r\n            operand = new Operand(this, expectRelative);\r\n\r\n            if(operand.expression && operand.expression.hasSymbols)\r\n                this.needsRecompilation = true;\r\n\r\n            operands.push(operand);\r\n\r\n            if(operand.reg >= 16 || operand.reg2 >= 16 || operand.size == 512)\r\n                vexInfo.evex = true;\r\n            if(operand.type.isMemory)\r\n            {\r\n                memoryOperand = operand;\r\n                if(enforcedSize)\r\n                    operand.size = enforcedSize;\r\n            }\r\n            else if(enforcedSize)\r\n                throw new ASMError(\"Size hints work only for memory operands\", sizePtrRange);\r\n\r\n            while(token == '{') // Decorator (mask or broadcast specifier)\r\n            {\r\n                vexInfo.evex = true;\r\n                if(this.syntax.prefix ? next() == '%' : next()[0] == 'k') // Opmask\r\n                {\r\n                    vexInfo.mask = parseRegister([OPT.MASK]).reg;\r\n                    if((vexInfo.mask & 7) == 0)\r\n                        throw new ASMError(`Can't use ${this.syntax.prefix ? '%' : ''}k0 as writemask`, regParsePos);\r\n                }\r\n                else if(token == 'z')\r\n                    vexInfo.zeroing = true, next(); // Zeroing-masking\r\n                else if(operand.type === OPT.MEM)\r\n                {\r\n                    vexInfo.broadcastOperand = operand;\r\n                    vexInfo.broadcast = [\"1to2\", \"1to4\", \"1to8\", \"1to16\"].indexOf(token) + 1;\r\n                    if(vexInfo.broadcast == 0)\r\n                        throw new ASMError(\"Invalid broadcast mode\");\r\n                    vexInfo.broadcastPos = currRange;\r\n                    next();\r\n                }\r\n                else\r\n                    throw new ASMError(\"Invalid decorator\");\r\n                \r\n                if(token != '}')\r\n                    throw new ASMError(\"Expected '}'\");\r\n                next();\r\n            }\r\n\r\n            if(token != ',')\r\n                break;\r\n            next();\r\n        }\r\n        this.operandStartPos = operands.length > 0 ? operands[0].startPos : this.opcodeRange;\r\n        if(this.syntax.intel && !(operands.length == 2 && operands[0].type === OPT.IMM && operands[1].type === OPT.IMM))\r\n            operands.reverse();\r\n\r\n        if(memoryOperand && vexInfo.round !== null)\r\n            throw new ASMError(\"Embedded rounding can only be used on reg-reg\", vexInfo.roundingPos);\r\n        \r\n        if(memoryOperand && this.prefsToGen.ADDRSIZE)\r\n            memoryOperand.dispSize = 32;\r\n        \r\n        if(this.prefsToGen.EVEX) // User has specified they want the EVEX encoding\r\n            vexInfo.evex = true;\r\n\r\n        // Filter out operations whose types don't match\r\n        /** @type {MnemonicInterpretation[]} */\r\n        let matchingInterps = [];\r\n        for(const interp of interps)\r\n        {\r\n            vexInfo.needed = interp.vex;\r\n            const matchingOps = interp.operations.filter(operation => operation.matchTypes(operands, vexInfo));\r\n            if(matchingOps.length > 0)\r\n                matchingInterps.push({ ...interp, operations: matchingOps })\r\n        }\r\n\r\n        if(matchingInterps.length == 0) // No operations match; find out why\r\n            throw new ASMError(explainNoMatch(interps, operands, vexInfo), this.operandStartPos.until(currRange));\r\n\r\n        this.outline = { operands, memoryOperand, interps: matchingInterps, vexInfo };\r\n        this.endPos = currRange;\r\n\r\n        this.removed = false; // Interpreting was successful, so don't mark as removed\r\n\r\n        try\r\n        {\r\n            this.compile();\r\n        }\r\n        catch(e)\r\n        {\r\n            this.error = e;\r\n            this.clear();\r\n        }\r\n        if(!this.needsRecompilation && !this.ipRelative)\r\n            this.outline = undefined;\r\n    }\r\n\r\n    compile()\r\n    {\r\n        if(this.outline === undefined)\r\n            throw ASMError(\"Critical error: unneeded recompilation\");\r\n\r\n        let { operands, memoryOperand, interps, vexInfo } = this.outline;\r\n        let prefsToGen = this.prefsToGen;\r\n        this.clear();\r\n\r\n        if(memoryOperand)\r\n            memoryOperand.evaluate(this, this.syntax.intel);\r\n\r\n        // Before we compile, we'll get the immediates' sizes\r\n        for(let i = 0; i < operands.length; i++)\r\n        {\r\n            const op = operands[i];\r\n            prefsToGen.add(op.prefs);\r\n            if(op.type === OPT.IMM)\r\n            {\r\n                if(op.expression.hasSymbols)\r\n                    op.evaluate(this);\r\n                if(op.value.isRelocatable())\r\n                {\r\n                    // Get the maximum possible value for this relocatable immediate\r\n                    const firstInterp = interps[0];\r\n                    if(firstInterp.operations.length == 1)\r\n                    {\r\n                        let operation = firstInterp.operations[0];\r\n                        op.size = Math.max(\r\n                            ...(firstInterp.vex ? operation.vexOpCatchers : operation.opCatchers)[i].sizes\r\n                        ) & ~7;\r\n                    }\r\n                    else\r\n                    {\r\n                        op.size = 8;\r\n                        relocationSizeLoop:\r\n                        for(const interp of interps) for(const operation of interp.operations)\r\n                        {\r\n                            const sizes = (interp.vex ? operation.vexOpCatchers : operation.opCatchers)[i].sizes\r\n                            if(sizes.length != 1 || (sizes[0] & ~7) != 8)\r\n                            {\r\n                                op.size = operands.length > 2 ? operands[2].size : operands[1].size;\r\n                                if(op.size > 32)\r\n                                    op.size = 32;\r\n                                break relocationSizeLoop;\r\n                            }\r\n                        }\r\n                    }\r\n                    op.unsignedSize = op.size;\r\n                }\r\n                else if(!op.expression.hasSymbols)\r\n                {\r\n                    op.size = op.value.inferSize(true);\r\n                    op.unsignedSize = op.value.inferSize(false);\r\n                }\r\n                else\r\n                {\r\n                    let max = op.value.inferSize();\r\n                    for(let size = 8; size <= max; size *= 2)\r\n                    {\r\n                        if((size != op.size || op.size == max) && op.sizeAllowed(size))\r\n                        {\r\n                            op.size = size;\r\n                            op.recordSizeUse(size);\r\n\r\n                            if(size < max)\r\n                                queueRecomp(this);\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    max = op.value.inferSize(false);\r\n\r\n                    for(let size = 8; size <= max; size *= 2)\r\n                    {\r\n                        if((size != op.unsignedSize || op.unsignedSize == max) && op.sizeAllowed(size, true))\r\n                        {\r\n                            op.unsignedSize = size;\r\n                            op.recordSizeUse(size, true);\r\n                            if(size < max)\r\n                                queueRecomp(this);\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now, we'll find the matching operation for this operand list\r\n        let op, found = false, rexVal = 0x40, memOpSize = memoryOperand?.size;\r\n        \r\n        interpLoop:\r\n        for(const interp of interps)\r\n        {\r\n            if(memoryOperand)\r\n                memoryOperand.size = interp.size || memOpSize;\r\n\r\n            vexInfo.needed = interp.vex;\r\n            for(const operation of interp.operations)\r\n            {\r\n                op = operation.fit(operands, this, vexInfo);\r\n                if(op !== null)\r\n                {\r\n                    found = true;\r\n                    break interpLoop;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(!found)\r\n        {\r\n            if(memoryOperand && isNaN(memoryOperand.size))\r\n                throw new ASMError(\"Ambiguous memory size\", memoryOperand.startPos.until(memoryOperand.endPos));\r\n\r\n            throw new ASMError(\r\n                \"Wrong operand size\" + (operands.length == 1 ? '' : 's'),\r\n                this.operandStartPos.until(this.endPos)\r\n            );\r\n        }\r\n\r\n        if(op.rexw)\r\n            rexVal |= 8, prefsToGen.REX = true; // REX.W field\r\n        \r\n        let modRM = null, sib = null;\r\n        if(op.extendOp)\r\n            rexVal |= 1, prefsToGen.REX = true;\r\n        else if(op.rm !== null)\r\n        {\r\n            let extraRex;\r\n            [extraRex, modRM, sib] = this.makeModRM(op.rm, op.reg);\r\n            if(extraRex !== 0)\r\n                rexVal |= extraRex, prefsToGen.REX = true;\r\n        }\r\n\r\n        // To encode ah/ch/dh/bh a REX prefix must not be present (otherwise they'll read as spl/bpl/sil/dil)\r\n        if(prefsToGen.REX && prefsToGen.NOREX)\r\n            throw new ASMError(\"Can't encode high 8-bit register\", operands[0].startPos.until(currRange));\r\n        let opcode = op.opcode;\r\n\r\n        if(op.size == 16)\r\n            prefsToGen.DATASIZE = true;\r\n\r\n        // Time to generate!\r\n        if(prefsToGen.SEG0) this.genByte(0x26);\r\n        if(prefsToGen.SEG1) this.genByte(0x2E);\r\n        if(prefsToGen.SEG2) this.genByte(0x36);\r\n        if(prefsToGen.SEG3) this.genByte(0x3E);\r\n        if(prefsToGen.SEG4) this.genByte(0x64);\r\n        if(prefsToGen.SEG5) this.genByte(0x65);\r\n\r\n        if(prefsToGen.ADDRSIZE) this.genByte(0x67);\r\n        if(prefsToGen.DATASIZE) this.genByte(0x66);\r\n\r\n        if(prefsToGen.LOCK)  this.genByte(0xF0);\r\n        if(prefsToGen.REPNE) this.genByte(0xF2);\r\n        if(prefsToGen.REPE)  this.genByte(0xF3)\r\n\r\n        if(op.prefix !== null)\r\n        {\r\n            if(op.prefix > 0xff)\r\n                this.genByte(op.prefix >> 8);\r\n            this.genByte(op.prefix);\r\n        }\r\n        if(op.vex !== null)\r\n            makeVexPrefix(op.vex, rexVal, vexInfo.evex).map(x => this.genByte(x));\r\n        else\r\n        {\r\n            if(prefsToGen.REX)\r\n                this.genByte(rexVal);\r\n            // Generate the upper bytes of the opcode if needed\r\n            if(opcode > 0xffff)\r\n                this.genByte(opcode >> 16);\r\n            if(opcode > 0xff)\r\n                this.genByte(opcode >> 8);\r\n        }\r\n        this.genByte(opcode);\r\n        if(modRM !== null)\r\n            this.genByte(modRM);\r\n        if(sib !== null)\r\n            this.genByte(sib);\r\n\r\n        // Generating the displacement\r\n        if(op.rm?.value?.addend != null)\r\n        {\r\n            let sizeRelative = false, value = op.rm.value;\r\n            if(op.rm.ripRelative && op.rm.value.section != pseudoSections.ABS && !op.rm.value.pcRelative)\r\n            {\r\n                for (let imm of op.imms)\r\n                    value.addend -= BigInt(imm.size >> 3);\r\n\r\n                sizeRelative = true;\r\n                value.apply(this, '-', new IdentifierValue({\r\n                    addend: BigInt(this.address),\r\n                    symbol: (this.section.head.statement ?? instr).symbol,\r\n                    section: this.section,\r\n                    range: value.range\r\n                }));\r\n                this.ipRelative = true;\r\n            }\r\n            this.genValue(value, {\r\n                size: op.rm.dispSize || 32,\r\n                signed: true,\r\n                sizeRelative,\r\n                dispMul: op.dispMul\r\n            });\r\n        }\r\n        if(op.relImm !== null)\r\n            this.genValue(op.relImm.value, { size: op.relImm.size, sizeRelative: true, functionAddr: true });\r\n        else if(op.evexImm !== null)\r\n            this.genByte(op.evexImm);\r\n        else if(op.moffs !== null)\r\n            this.genValue(op.moffs.value, { size: op.moffs.dispSize, signed: true });\r\n        else for(const imm of op.imms)\r\n            this.genValue(imm.value, { size: imm.size, signed: !op.unsigned });\r\n        \r\n    }\r\n\r\n    /** Generate the ModRM byte\r\n     * @param {Operand} rm\r\n     * @param {Operand} r */\r\n    makeModRM(rm, r)\r\n    {\r\n        let modrm = 0, rex = 0, sib = null;\r\n        // rm's and r's values may be edited, however the objects themselves shouldn't be modified\r\n        let rmReg = rm.reg, rmReg2 = rm.reg2, rReg = r.reg;\r\n\r\n        // Encoding the \"reg\" field\r\n        if(rReg >= 8)\r\n        {\r\n            rex |= 4; // rex.R extension\r\n            rReg &= 7;\r\n        }\r\n        modrm |= rReg << 3;\r\n\r\n        // Special case for RIP-relative addressing\r\n        if(rm.ripRelative)\r\n        {\r\n            rm.value.addend = rm.value.addend || 0n;\r\n            // mod = 00, reg = (reg), rm = 101\r\n            return [rex, modrm | 5, null];\r\n        }\r\n\r\n        // Encoding the \"mod\" (modifier) field\r\n        if(!rm.type.isMemory)\r\n            modrm |= 0xC0; // mod=11\r\n        else if(rmReg >= 0)\r\n        {\r\n            if(rm.value.addend != null)\r\n            {\r\n                this.determineDispSize(rm, 8, 32);\r\n                if(rm.dispSize == 8)\r\n                    modrm |= 0x40; // mod=01\r\n                else\r\n                    modrm |= 0x80; // mod=10\r\n            }\r\n        }\r\n        else // mod = 00\r\n        {\r\n            // These are the respective \"none\" type registers\r\n            rmReg = 5;\r\n            if(currBitness == 64 && rmReg2 < 0)\r\n                rmReg2 = 4;\r\n            rm.value.addend ||= 0n;\r\n        }\r\n        \r\n        // Encoding the \"rm\" field\r\n        rex |= rmReg >> 3; // rex.B extension\r\n        rmReg &= 7;\r\n\r\n        // If we have an index register, we need an SIB byte to encode it\r\n        modrm |= rmReg2 < 0 ? rmReg : 4;\r\n\r\n        // Encoding an SIB byte if necessary\r\n        if((modrm & 0xC0) != 0xC0 && (modrm & 7) == 4) // mod!=11, rm=100 signifies an SIB byte follows\r\n        {\r\n            if(rmReg2 < 0)\r\n                rmReg2 = 4; // indicating the \"none\" index\r\n            else if(rmReg2 >= 8)\r\n            {\r\n                rex |= 2; // rex.X extension\r\n                rmReg2 &= 7;\r\n            }\r\n            \r\n            sib = (rm.shift << 6) | (rmReg2 << 3) | rmReg;\r\n        }\r\n        return [rex, modrm, sib];\r\n    }\r\n\r\n    /** Determine whether to shorten a memory operand's displacement if possible,\r\n     * and queue for recompilation as necessary\r\n     * @param {Operand} operand The memory operand to determine\r\n     * @param {Number} shortSize The possible short size\r\n     * @param {Number} longSize The default long size */\r\n    determineDispSize(operand, shortSize, longSize)\r\n    {\r\n        if(!operand.value.isRelocatable() && operand.value.inferSize() <= shortSize && (operand.dispSize == shortSize || operand.sizeAvailable(SHORT_DISP)))\r\n        {\r\n            operand.dispSize = shortSize;\r\n            operand.recordSizeUse(SHORT_DISP);\r\n        }\r\n        else if(!operand.value.isRelocatable() && operand.expression && operand.expression.hasSymbols && operand.dispSize != shortSize && operand.sizeAvailable(SHORT_DISP))\r\n        {\r\n            operand.dispSize = shortSize;\r\n            operand.recordSizeUse(SHORT_DISP);\r\n            queueRecomp(this);\r\n        }\r\n        else\r\n            operand.dispSize = longSize;\r\n    }\r\n\r\n    recompile()\r\n    {\r\n        this.error = null;\r\n        try\r\n        {\r\n            for(const op of this.outline.operands)\r\n                if(op.expression && op.expression.hasSymbols)\r\n                    op.value = op.expression.evaluate(this);\r\n\r\n            this.compile();\r\n        }\r\n        catch(e)\r\n        {\r\n            this.clear();\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n\r\n// Generate the VEX/EVEX prefix\r\nfunction makeVexPrefix(vex, rex, isEvex)\r\n{\r\n    if(isEvex)\r\n        vex ^= 0x80010; // Invert the V' and R' bits\r\n\r\n    let vex1 = vex & 255, vex2 = vex >> 8, vex3 = vex >> 16;\r\n    // The first 3 fields are identical to the last 3 in rex (R, X, B), but inverted\r\n    vex1 |= ((~rex & 7) << 5);\r\n    vex2 |= (((rex & 8)) << 4); // VEX.w = REX.w\r\n\r\n    if(isEvex)\r\n        return [0x62, vex1, vex2, vex3];\r\n\r\n    if((vex1 & 0x7F) == 0x61 && (vex2 & 0x80) == 0) // In certain cases, we can compress the prefix to 2 bytes\r\n        return [0xC5, vex2 | (vex1 & 0x80)];\r\n\r\n    return [0xC4, vex1, vex2];\r\n}", "import { ASMError, token, next, match, loadCode, currRange, currSyntax, setSyntax, prevRange, line, comment, Range, startAbsRange, RelativeRange, ungetToken } from \"./parser.js\";\r\nimport { isDirective, makeDirective } from \"./directives.js\";\r\nimport { Instruction } from \"./instructions.js\";\r\nimport { SymbolDefinition, recompQueue, queueRecomp, loadSymbols, symbols } from \"./symbols.js\";\r\nimport { Statement, StatementNode } from \"./statement.js\";\r\nimport { loadSections, Section, sectionFlags, sections } from \"./sections.js\";\r\n\r\n/** @type {StatementNode} */ var prevNode = null;\r\n/** @type {Section}       */ export var currSection = null;\r\n/** @type {32 | 64}       */ export var currBitness;\r\n\r\nvar addr = 0;\r\n\r\n/** @param {Section} section */\r\nfunction setSection(section)\r\n{\r\n    currSection = section;\r\n    const prevInstr = section.cursor.prev.statement;\r\n    return prevInstr.address + prevInstr.length;\r\n}\r\n\r\n/** @param {Statement} instr */\r\nfunction addInstruction(instr, seekEnd = true)\r\n{\r\n    if(instr.section !== currSection)\r\n        instr.address = setSection(instr.section);\r\n        \r\n    prevNode                = prevNode.next                = new StatementNode(instr);\r\n    currSection.cursor.prev = currSection.cursor.prev.next = instr.sectionNode;\r\n    setSyntax(instr.syntax);\r\n\r\n    if(seekEnd && token != '\\n' && token != ';')\r\n    {\r\n        // Special case: this error should appear but not remove the instruction's bytes\r\n        instr.error = new ASMError(\"Expected end of line\");\r\n        while(token != '\\n' && token != ';')\r\n            next();\r\n    }\r\n\r\n    addr = instr.address + instr.length;\r\n    instr.range.length = (seekEnd ? currRange.start : currRange.end) - instr.range.start;\r\n}\r\n\r\n/**\r\n * @typedef {Object} AssemblyConfig\r\n * @property {import('@defasm/core/parser.js').Syntax} config.syntax The initial syntax to use\r\n * @property {boolean} config.writableText Whether the .text section should be writable\r\n * @property {32|64} config.bitness Whether to use the 64- or 32-bit instruction set\r\n */\r\n\r\nexport class AssemblyState\r\n{ \r\n    /** @param {AssemblyConfig} */\r\n    constructor({\r\n        syntax = {\r\n            intel: false,\r\n            prefix: true\r\n        },\r\n        writableText = false,\r\n        bitness = 64\r\n    } = {})\r\n    {\r\n        this.defaultSyntax = syntax;\r\n        this.bitness = bitness;\r\n\r\n        /** @type {Map<string, import(\"./symbols.js\").Symbol>} */\r\n        this.symbols = new Map();\r\n        /** @type {string[]} */\r\n        this.fileSymbols = [];\r\n\r\n        setSyntax(syntax);\r\n        loadSymbols(this.symbols, this.fileSymbols);\r\n        currBitness = bitness;\r\n\r\n        /** @type {Section[]} */\r\n        this.sections = [\r\n            new Section('.text'),\r\n            new Section('.data'),\r\n            new Section('.bss')\r\n        ];\r\n\r\n        if(writableText)\r\n            this.sections[0].flags |= sectionFlags.w;\r\n\r\n        this.head = new StatementNode();\r\n\r\n        /** @type {string} */\r\n        this.source = '';\r\n\r\n        /** @type {Range} */\r\n        this.compiledRange = new Range();\r\n\r\n        /** @type {ASMError[]} */\r\n        this.errors = [];\r\n    }\r\n\r\n    /** Compile Assembly from source code into machine code \r\n     * @param {string} source\r\n    */\r\n    compile(source, {\r\n        haltOnError = false,\r\n        range: replacementRange = new Range(0, this.source.length),\r\n        doSecondPass = true } = {})\r\n    {\r\n        this.source =\r\n            /* If the given range is outside the current\r\n            code's span, fill the in-between with newlines */\r\n            this.source.slice(0, replacementRange.start).padEnd(replacementRange.start, '\\n') +\r\n            source +\r\n            this.source.slice(replacementRange.end);\r\n        \r\n        loadSymbols(this.symbols, this.fileSymbols);\r\n        loadSections(this.sections, replacementRange);\r\n        currBitness = this.bitness;\r\n\r\n        let { head, tail } = this.head.getAffectedArea(replacementRange, true, source.length);\r\n        \r\n        setSyntax(head.statement ? head.statement.syntax : this.defaultSyntax);\r\n        addr = setSection(head.statement ? head.statement.section : this.sections[0]);\r\n        loadCode(this.source, replacementRange.start);\r\n\r\n        prevNode = head;\r\n\r\n        while(match)\r\n        {\r\n            let range = startAbsRange();\r\n            try\r\n            {\r\n                if(token != '\\n' && token != ';')\r\n                {\r\n                    let name = token;\r\n                    next();\r\n                    if(token == ':') // Label definition\r\n                        addInstruction(new SymbolDefinition({ addr, name, range, isLabel: true }), false);\r\n                    else if(token == '=' || currSyntax.intel && token.toLowerCase() == 'equ') // Symbol definition\r\n                        addInstruction(new SymbolDefinition({ addr, name, range }));\r\n                    else\r\n                    {\r\n                        let isDir = false;\r\n                        if(currSyntax.intel)\r\n                        {\r\n                            if(name[0] == '%')\r\n                            {\r\n                                isDir = true;\r\n                                name += token.toLowerCase();\r\n                                next();\r\n                            }\r\n                            else\r\n                                isDir = isDirective(name, true);\r\n                        }\r\n                        else\r\n                            isDir = name[0] == '.';\r\n                        \r\n                        if(isDir) // Assembler directive\r\n                            addInstruction(makeDirective({ addr, range }, currSyntax.intel ? name : name.slice(1)));\r\n                        else if(currSyntax.intel && isDirective(token, true)) // \"<label> <directive>\"\r\n                        {\r\n                            addInstruction(new SymbolDefinition({ addr, name, range, isLabel: true }), false);\r\n                            name = token; range = startAbsRange();\r\n                            next();\r\n                            addInstruction(makeDirective({ addr, range }, name));\r\n                        }\r\n                        else // Instruction\r\n                            addInstruction(new Instruction({ addr, name, range }));\r\n                    }\r\n                }\r\n            }\r\n            catch(error)\r\n            {\r\n                while(token != '\\n' && token != ';')\r\n                    next();\r\n                    \r\n                if(haltOnError && !(doSecondPass && error.range))\r\n                    throw `Error on line ${line}: ${error.message}`;\r\n                if(!error.range)\r\n                    console.error(`Error on line ${line}:\\n`, error);\r\n                else\r\n                    addInstruction(new Statement({ addr, range, error }), !comment);\r\n            }\r\n            if(comment)\r\n                addInstruction(new Statement({ addr, range: startAbsRange() }), false);\r\n\r\n            next();\r\n            if(currRange.end > replacementRange.end)\r\n                break;\r\n        }\r\n\r\n        // Correct the tails' positions, in case more instructions were parsed than initially thought\r\n        for(const section of sections)\r\n        {\r\n            let node = section.cursor.tail;\r\n            while(node && node.statement.range.start < currRange.start)\r\n                node = node.next;\r\n            section.cursor.tail = node;\r\n        }\r\n\r\n        while(tail && tail.statement.range.start < currRange.start)\r\n        {\r\n            tail.statement.remove();\r\n            tail = tail.next;\r\n        }\r\n\r\n        // If a replacement causes a section's span to change, this will correct the cursors\r\n        if(tail && currSection !== tail.statement.section && !tail.statement.switchSection)\r\n        {\r\n            let tailSection = tail.statement.section;\r\n            let node = tailSection.cursor.tail;\r\n            currSection.cursor.prev.next = node;\r\n            while(node && !node.statement.switchSection)\r\n            {\r\n                node.statement.section = currSection;\r\n                if(node.statement.ipRelative)\r\n                    queueRecomp(node.statement);\r\n                currSection.cursor.prev = node;\r\n                node = node.next;\r\n            }\r\n            tailSection.cursor.tail = node;\r\n        }\r\n\r\n        // Link the cursors' last nodes to their tail nodes\r\n        for(const section of sections)\r\n        {\r\n            let prev = section.cursor.prev;\r\n            prev.next = section.cursor.tail;\r\n\r\n            /* To update the addresses following the insertion, add the last\r\n            inserted statement to the recompilation queue.\r\n            We don't call queueRecomp because that function also marks the\r\n            statement as wanting recompilation, which it doesn't - it's only\r\n            queued so it can update the addresses of the proceeding statements. */\r\n            if(prev.next)\r\n                recompQueue.push(prev);\r\n        }\r\n        \r\n        prevNode.next = tail;\r\n\r\n        if(tail)\r\n        {\r\n            let instr = tail.statement;\r\n\r\n            if((currSyntax.prefix != instr.syntax.prefix || currSyntax.intel != instr.syntax.intel) && !instr.switchSyntax)\r\n            {\r\n                // Syntax has been changed, we have to recompile some of the source\r\n                let nextSyntaxChange = tail;\r\n                while(nextSyntaxChange.next && !nextSyntaxChange.next.switchSyntax)\r\n                    nextSyntaxChange = nextSyntaxChange.next;\r\n                \r\n                const recompStart = prevNode.statement ? prevNode.statement.range.end : 0;\r\n                const recompEnd = nextSyntaxChange.statement.range.end;\r\n                const recompRange = new Range(recompStart, recompEnd - recompStart);\r\n                \r\n                this.compile(recompRange.slice(this.source), {\r\n                    haltOnError,\r\n                    range: recompRange,\r\n                    doSecondPass: false\r\n                });\r\n            }\r\n        }\r\n\r\n        this.compiledRange = replacementRange.until(prevRange);\r\n\r\n        if(doSecondPass)\r\n            this.secondPass(haltOnError);\r\n    }\r\n\r\n    // Run the second pass on the instruction list\r\n    secondPass(haltOnError = false)\r\n    {\r\n        addr = 0;\r\n        let node;\r\n        loadSymbols(this.symbols);\r\n\r\n        symbols.forEach((symbol, name) => {\r\n            symbol.references = symbol.references.filter(instr => !instr.removed);\r\n            symbol.definitions = symbol.definitions.filter(instr => !instr.removed);\r\n            if((symbol.statement === null || symbol.statement.error) && symbol.references.length == 0 && symbol.definitions.length == 0)\r\n                symbols.delete(name);\r\n        });\r\n\r\n        /* For efficiency (and also to fix certain edge cases), we'll make sure\r\n        to recompile in order of statement address. */\r\n        recompQueue.sort((a, b) => a.statement.address - b.statement.address);\r\n\r\n        while(node = recompQueue.shift())\r\n        {\r\n            addr = node.statement.address;\r\n            do\r\n            {\r\n                let instr = node.statement;\r\n                if(instr)\r\n                {\r\n                    instr.address = addr;\r\n                    if((instr.wantsRecomp || instr.ipRelative) && !instr.removed)\r\n                    {\r\n                        // Recompiling the instruction\r\n                        try\r\n                        {\r\n                            instr.wantsRecomp = false;\r\n                            instr.recompile();\r\n                        }\r\n                        catch(e)\r\n                        {\r\n                            instr.error = e;\r\n\r\n                            // When a symbol is invalidated, all references to it should be too\r\n                            if(instr.symbol)\r\n                                for(const ref of instr.symbol.references)\r\n                                    queueRecomp(ref);\r\n                        }\r\n                    }\r\n                    addr = instr.address + instr.length;\r\n                }\r\n                node = node.next;\r\n            } while(node && node.statement.address != addr);\r\n        }\r\n\r\n        // Error collection\r\n        this.errors = [];\r\n        const reportedErrors = []\r\n        this.iterate((instr, line) => {\r\n            if(instr.outline && instr.outline.operands)\r\n                for(let op of instr.outline.operands)\r\n                    op.clearAttemptedSizes();\r\n\r\n            const error = instr.error;\r\n            if(error)\r\n            {\r\n                this.errors.push(error);\r\n\r\n                /* Errors whose pos can't be determined should be logged\r\n                to the console (these are usually internal compiler errors) */\r\n                if(!error.range)\r\n                {\r\n                    console.error(`Error on line ${line}:\\n`, error);\r\n                    error.range = new RelativeRange(instr.range, instr.range.start, instr.range.length);\r\n                }\r\n                reportedErrors.push({ line, error });\r\n            }\r\n        });\r\n\r\n        if(haltOnError && reportedErrors.length > 0)\r\n            throw reportedErrors.map(({ error, line }) => {\r\n                const linePart = `Error on line ${line}: `;\r\n                return linePart + (error.range.parent ?? error.range).slice(this.source) +\r\n                '\\n' + ' '.repeat(linePart.length + (error.range.parent ? error.range.start - error.range.parent.start : 0)) +\r\n                '^ ' + error.message\r\n            }).join('\\n\\n');\r\n    }\r\n\r\n    line(line)\r\n    {\r\n        if(line-- < 1)\r\n            throw \"Invalid line\";\r\n        let start = 0;\r\n        while(line)\r\n        {\r\n            start = this.source.indexOf('\\n', start) + 1;\r\n            if(start == 0)\r\n                return new Range(this.source.length + line, 0);\r\n            line--;\r\n        }\r\n\r\n        let end = this.source.indexOf('\\n', start);\r\n        if(end < 0)\r\n            end = this.source.length;\r\n        return new Range(start, end - start);\r\n    }\r\n\r\n    /**\r\n     * @callback instrCallback\r\n     * @param {Statement} instr\r\n     * @param {Number} line\r\n    */\r\n    /** @param {instrCallback} func */\r\n    iterate(func)\r\n    {\r\n        let line = 1, nextLine = 0, node = this.head.next;\r\n        while(nextLine != Infinity)\r\n        {\r\n            nextLine = this.source.indexOf('\\n', nextLine) + 1 || Infinity;\r\n            while(node && node.statement.range.end < nextLine)\r\n            {\r\n                func(node.statement, line);\r\n                node = node.next;\r\n            }\r\n            line++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @callback lineCallback\r\n     * @param {Uint8Array} bytes\r\n     * @param {Number} line\r\n    */\r\n    /** @param {lineCallback} func */\r\n    bytesPerLine(func)\r\n    {\r\n        let lineQueue = [];\r\n        let line = 1, nextLine = 0, node = this.head.next;\r\n        while(nextLine != Infinity)\r\n        {\r\n            let bytes = new Uint8Array();\r\n            let addToBytes = () => {\r\n                if(lineQueue.length > 0)\r\n                {\r\n                    const line = lineQueue.shift();\r\n                    if(line.length > 0)\r\n                    {\r\n                        let newBytes = new Uint8Array(bytes.length + line.length);\r\n                        newBytes.set(bytes);\r\n                        newBytes.set(line, bytes.length);\r\n                        bytes = newBytes;\r\n                    }\r\n                }\r\n            }\r\n            nextLine = this.source.indexOf('\\n', nextLine) + 1 || Infinity;\r\n            addToBytes();\r\n\r\n            while(node && node.statement.range.start < nextLine)\r\n            {\r\n                let instr = node.statement, prevEnd = 0;\r\n                for(const end of [...instr.lineEnds, instr.length])\r\n                {\r\n                    if(end <= instr.length)\r\n                        lineQueue.push(instr.bytes.subarray(prevEnd, end));\r\n                    prevEnd = end;\r\n                }\r\n                addToBytes();\r\n                node = node.next;\r\n            }\r\n            func(bytes, line);\r\n            line++;\r\n        }\r\n    }\r\n}", "import { pseudoSections } from '@defasm/core/sections.js';\nimport { Buffer } from \"buffer\";\n\nconst relocTypesAMD64 = {\n    NONE      : 0,\n    64        : 1,\n    PC32      : 2,\n    GOT32     : 3,\n    PLT32     : 4,\n    COPY      : 5,\n    GLOB_DAT  : 6,\n    JUMP_SLOT : 7,\n    RELATIVE  : 8,\n    GOTPCREL  : 9,\n    32        : 10,\n    '32S'     : 11,\n    16        : 12,\n    PC16      : 13,\n    8         : 14,\n    PC8       : 15,\n    PC64      : 24,\n    GOTOFF64  : 25,\n    GOTPC32   : 26,\n    SIZE32    : 32,\n    SIZE64    : 33\n};\n\nconst relocTypes386 = {\n    NONE      : 0,\n    32        : 1,\n    PC32      : 2,\n    GOT32     : 3,\n    PLT32     : 4,\n    COPY      : 5,\n    GLOB_DAT  : 6,\n    JUMP_SLOT : 7,\n    RELATIVE  : 8,\n    GOTOFF    : 9,\n    GOTPC     : 10,\n    \"32PLT\"   : 11\n};\n\n/**\n * @param {T} fields \n * @template T \n */\nfunction header(fields)\n{\n    const result = class\n    {\n        #fields;\n        /** @param {T} config */\n        constructor(config)\n        {\n            for(const name of Object.keys(fields))\n                this[name] = config[name] ?? 0;\n            this.#fields = fields;\n        }\n\n        dump(wordSize)\n        {\n            const data = Buffer.alloc(result.size(wordSize));\n            for(const name of Object.keys(this.#fields))\n            {\n                let [offset, size] = fields[name], number = this[name];\n                if(Array.isArray(offset)) offset = offset[wordSize >> 6];\n                if(Array.isArray(size))   size   = size[wordSize >> 6];\n\n                switch(size)\n                {\n                    case 1: data.writeInt8(number, offset); break;\n                    case 2: data.writeInt16LE(number, offset); break;\n                    case 4: data.writeInt32LE(number, offset); break;\n                    case 8: data.writeBigInt64LE(BigInt(number), offset); break;\n                }\n            }\n            return data;\n        }\n\n        static size(wordSize)\n        {\n            let length = 0;\n            for(let [offset, size] of Object.values(fields))\n            {\n                if(Array.isArray(offset)) offset = offset[wordSize >> 6];\n                if(Array.isArray(size))   size   = size[wordSize >> 6];\n                length = Math.max(length, offset + size);\n            }\n            return length;\n        }\n    };\n    return result;\n}\n\nexport const ELFHeader = header({\n    /** 0x7F followed by ELF(45 4c 46) in ASCII; these four bytes constitute the magic number. */\n    EI_MAG:        [0x00, 4],\n    /** This byte is set to either 1 or 2 to signify 32- or 64-bit format, respectively. */\n    EI_CLASS:      [0x04, 1],\n    /** This byte is set to either 1 or 2 to signify little or big endianness, respectively. This affects interpretation of multi-byte fields starting with offset 0x10. */\n    EI_DATA:       [0x05, 1],\n    /** Set to 1 for the original and current version of ELF. */\n    EI_VERSION:    [0x06, 1],\n    /** Identifies the target operating system ABI. It is often set to 0 regardless of the target platform. */\n    EI_OSABI:      [0x07, 1],\n    /** Further specifies the ABI version. Its interpretation depends on the target ABI. Linux kernel (after at least 2.6) has no definition of it, so it is ignored for statically-linked executables. */\n    EI_ABIVERSION: [0x08, 1],\n    /** currently unused, should be filled with zeros. */\n    EI_PAD:        [0x09, 7],\n    /** Identifies object file type. */\n    e_type:        [0x10, 2],\n    /** Specifies target instruction set architecture. */\n    e_machine:     [0x12, 2],\n    /** Set to 1 for the original version of ELF. */\n    e_version:     [0x14, 4],\n    /** This is the memory address of the entry point from where the process starts executing. */\n    e_entry:       [0x18, [4, 8]],\n    /** Points to the start of the program header table. */\n    e_phoff:       [[0x1C, 0x20], [4, 8]],\n    /** Points to the start of the section header table. */\n    e_shoff:       [[0x20, 0x28], [4, 8]],\n    /** Interpretation of this field depends on the target architecture. */\n    e_flags:       [[0x24, 0x30], 4],\n    /** Contains the size of this header. */\n    e_ehsize:      [[0x28, 0x34], 2],\n    /** Contains the size of a program header table entry. */\n    e_phentsize:   [[0x2A, 0x36], 2],\n    /** Contains the number of entries in the program header table. */\n    e_phnum:       [[0x2C, 0x38], 2],\n    /** Contains the size of a section header table entry. */\n    e_shentsize:   [[0x2E, 0x3A], 2],\n    /** Contains the number of entries in the section header table. */\n    e_shnum:       [[0x30, 0x3C], 2],\n    /** Contains index of the section header table entry that contains the section names. */\n    e_shstrndx:    [[0x32, 0x3E], 2]\n});\n\nexport const ProgramHeader = header({\n    /** Identifies the type of the segment. */\n    p_type:  [0x00, 4],\n    /** Segment-dependent flags. */\n    p_flags:  [[0x18, 0x04], 4],\n    /** Offset of the segment in the file image. */\n    p_offset: [[0x04, 0x08], [4, 8]],\n    /** Virtual address of the segment in memory. */\n    p_vaddr:  [[0x08, 0x10], [4, 8]],\n    /** On systems where physical address is relevant, reserved for segment's physical address. */\n    p_paddr:  [[0x0C, 0x18], [4, 8]],\n    /** Size in bytes of the segment in the file image. May be 0. */\n    p_filesz: [[0x10, 0x20], [4, 8]],\n    /** Size in bytes of the segment in memory. May be 0. */\n    p_memsz:  [[0x14, 0x28], [4, 8]],\n    /** 0 and 1 specify no alignment. Otherwise should be a positive, integral power of 2, with p_vaddr equating p_offset modulus p_align. */\n    p_align:  [[0x1C, 0x30], [4, 8]],\n});\n\nexport const SectionHeader = header({\n    /** An offset to a string in the .shstrtab section that represents the name of this section. */\n    sh_name:      [0x00, 4],\n    /** Identifies the type of this header. */\n    sh_type:      [0x04, 4],\n    /** Identifies the attributes of the section. */\n    sh_flags:     [0x08, [4, 8]],\n    /** Virtual address of the section in memory, for sections that are loaded. */\n    sh_addr:      [[0x0C, 0x10], [4, 8]],\n    /** Offset of the section in the file image. */\n    sh_offset:    [[0x10, 0x18], [4, 8]],\n    /** Size in bytes of the section in the file image. May be 0. */\n    sh_size:      [[0x14, 0x20], [4, 8]],\n    /** Contains the section index of an associated section. This field is used for several purposes, depending on the type of section. */\n    sh_link:      [[0x18, 0x28], 4],\n    /** Contains extra information about the section. This field is used for several purposes, depending on the type of section. */\n    sh_info:      [[0x1C, 0x2C], 4],\n    /** Contains the required alignment of the section. This field must be a power of two. */\n    sh_addralign: [[0x20, 0x30], [4, 8]],\n    /** Contains the size, in bytes, of each entry, for sections that contain fixed-size entries. Otherwise, this field contains zero. */\n    sh_entsize:   [[0x24, 0x38], [4, 8]],\n});\n\nexport class ELFSection\n{\n    /**\n     * @param {Object} config\n     * @param {string} config.name\n     * @param {StringTable} config.shstrtab\n     * @param {number} config.type\n     * @param {Buffer} config.buffer\n     * @param {number} config.flags\n     * @param {number} config.address\n     * @param {number} config.entrySize\n     * @param {32 | 64} config.bitness\n     * @param {import('@defasm/core/sections.js').Section} config.section */\n    constructor({ type = 0, buffer = Buffer.alloc(0), flags = 0, address = 0, entrySize = 0, link = 0, info = 0, align = 1, linkSection = null, infoSection = null, section = null, bitness = 64 } = {})\n    {\n        this.buffer = buffer;\n        this.header = new SectionHeader({\n            sh_type: type,\n            sh_flags: flags,\n            sh_addr: address,\n            sh_addralign: align,\n            sh_size: buffer.length,\n            sh_link: link,\n            sh_entsize: entrySize,\n            sh_info: info,\n        });\n        this.entrySize = entrySize;\n        this.section = section;\n        this.linkSection = linkSection;\n        this.infoSection = infoSection;\n        this.bitness = bitness;\n    }\n\n    add(buffer)\n    {\n        this.buffer = Buffer.concat([this.buffer, buffer]);\n        this.header.sh_size = this.buffer.length;\n    }\n\n    /**\n     * @param {string} name\n     * @param {StringTable} shstrtab\n     */\n    name(name, shstrtab)\n    {\n        this.header.sh_name = shstrtab.getIndex(name);\n    }\n\n    setIndices(sections)\n    {\n        if(this.infoSection)\n            this.header.sh_info = sections.indexOf(this.infoSection) + 1;\n        if(this.linkSection)\n            this.header.sh_link = sections.indexOf(this.linkSection) + 1;\n        this.header.sh_size = this.buffer.length;\n    }\n}\n\nexport class StringTable extends ELFSection\n{\n    constructor(config)\n    {\n        super({ ...config, type: 0x3, buffer: Buffer.alloc(1) });\n        this.indices = { \"\": 0 };\n    }\n\n    getIndex(string)\n    {\n        if(!this.indices.hasOwnProperty(string)) \n        {\n            this.indices[string] = this.buffer.length;\n            this.add(Buffer.from(string + '\\0'));\n        }\n        return this.indices[string];\n    }\n}\n\nexport class SymbolTable extends ELFSection\n{\n    /**\n     * @param {import(\"@defasm/core/symbols\").Symbol[]} symbols\n     * @param {StringTable} strtab */\n    constructor(config, symbols, strtab)\n    {\n        super({ ...config, type: 0x2, entrySize: config.bitness === 64 ? 0x18 : 0x10, info: 1, align: 8 });\n        this.symbolCount = 1;\n        this.strtab = strtab;\n        this.symbols = symbols.filter(symbol => symbol.value.section != pseudoSections.UND || !symbol.value.symbol);\n    }\n\n    setIndices(sections)\n    {\n        this.buffer = Buffer.alloc(this.entrySize * (this.symbols.length + 1));\n        let index = this.entrySize, i = 1;\n        for(const symbol of this.symbols)\n        {\n            const val = symbol.value.flatten();\n\n            const st_name = this.strtab.getIndex(symbol.name);\n            const st_info = (symbol.type ?? 0) | (symbol.bind || (val.section == pseudoSections.UND ? 1 : 0)) << 4;\n            const st_other = symbol.visibility ?? 0;\n            const st_shndx = val.section.index;\n            const st_value = val.addend;\n            const st_size = symbol.size ?? 0;\n\n            if(this.bitness === 32) // Elf32_Sym\n            {\n                this.buffer.writeUInt32LE(st_name, index + 0x0);\n                this.buffer.writeUInt32LE(Number(st_value), index + 0x4);\n                this.buffer.writeUInt32LE(st_size, index + 0x8);\n                this.buffer.writeUInt8(st_info, index + 0xC);\n                this.buffer.writeUInt8(st_other, index + 0xD);\n                this.buffer.writeUInt16LE(st_shndx, index + 0xE);\n            }\n            else // Elf64_Sym\n            {\n                this.buffer.writeUInt32LE(st_name, index + 0x0);\n                this.buffer.writeUInt8(st_info, index + 0x4);\n                this.buffer.writeUInt8(st_other, index + 0x5);\n                this.buffer.writeUInt16LE(st_shndx, index + 0x6);\n                this.buffer.writeBigUInt64LE(st_value, index + 0x8);\n                this.buffer.writeBigUInt64LE(BigInt(st_size), index + 0x10);\n            }\n\n            if(!symbol.bind)\n                this.header.sh_info = i + 1;\n            \n            this.symbolCount++;\n            index += this.entrySize;\n            i++;\n        }\n        this.buffer = this.buffer.subarray(0, index);\n        super.setIndices(sections);\n    }\n}\n\nexport class RelocationSection extends ELFSection\n{\n    /**\n     * @param {import('@defasm/core/relocations').RelocEntry[]} relocations\n     * @param {SymbolTable} symtab */\n    constructor(config, relocations, symtab)\n    {\n        let entrySize = config.bitness === 64 ? 0x18 : 0xC;\n        super({ ...config, type: 0x4, entrySize, buffer: Buffer.alloc(entrySize * relocations.length), linkSection: symtab });\n        this.relocations = relocations;\n\n        for(const reloc of relocations)\n            if(reloc.symbol && !symtab.symbols.includes(reloc.symbol))\n                symtab.symbols.push(reloc.symbol);\n    }\n\n    setIndices(sections)\n    {\n        let index = 0, symtab = this.linkSection;\n        const relocTypes = this.bitness === 64 ? relocTypesAMD64 : relocTypes386;\n        for(const reloc of this.relocations)\n        {\n            const type = relocTypes[(reloc.pcRelative ? reloc.functionAddr ? 'PLT' : 'PC' : '') + reloc.size + (reloc.signed ? 'S' : '')];\n            const r_offset = reloc.offset;\n            const r_info_sym = reloc.symbol ? symtab.symbols.indexOf(reloc.symbol) + 1 : 0;\n            const r_info_type = type;\n            const r_addend = reloc.addend;\n\n            if(this.bitness === 32) // Elf32_Rela\n            {\n                this.buffer.writeUint32LE(r_offset, index + 0x00);\n                this.buffer.writeUint32LE((r_info_sym << 8) + r_info_type, index + 0x04);\n                this.buffer.writeInt32LE(Number(r_addend), index + 0x08);\n            }\n            else // Elf64_Rela\n            {\n                this.buffer.writeBigUInt64LE(BigInt(r_offset), index + 0x00);\n                this.buffer.writeBigUInt64LE((BigInt(r_info_sym) << 32n) + BigInt(r_info_type), index + 0x8);\n                this.buffer.writeBigInt64LE(BigInt(r_addend), index + 0x10);\n            }\n            index += this.entrySize;\n        }\n        super.setIndices(sections);\n    }\n}\n", "import { AssemblyState } from \"@defasm/core\";\nimport { ELFHeader, ELFSection, ProgramHeader, RelocationSection, SectionHeader, StringTable, SymbolTable } from \"./elf.js\";\nimport { pseudoSections, sectionFlags, STT_SECTION } from \"@defasm/core/sections.js\";\nimport { Buffer } from \"buffer\";\n\nclass OutputBuffer {\n    chunks = [];\n    length = 0;\n\n    write(buffer, position) {\n        this.chunks.push({buffer, position})\n        this.length = Math.max(this.length, position + buffer.length)\n    }\n\n    toUint8Array() {\n        const arr = new Uint8Array(this.length);\n        for (const {buffer, position} of this.chunks) {\n            arr.set(buffer, position);\n        }\n        return arr;\n    }\n}\n\n/**\n * @param {AssemblyState} state\n */\nexport function createObject(state)\n{\n    const outBuffer = new OutputBuffer();\n\n    /** @type {import(\"@defasm/core/symbols\").Symbol[]} */\n    let recordedSymbols = [];\n    for(const fileSymbol of state.fileSymbols)\n    {\n        recordedSymbols.push({\n            type: STT_FILE,\n            bind: 0,\n            name: fileSymbol,\n            size: 0,\n            visibility: 0,\n            value: { section: pseudoSections.ABS, addend: 0n }\n        });\n    }\n    state.symbols.forEach(symbol => {\n        if(symbol.type != STT_SECTION)\n            recordedSymbols.push(symbol);\n    });\n\n    const strtab = new StringTable();\n    let shstrtab = new StringTable(), symtab = new SymbolTable({ linkSection: strtab, bitness: state.bitness }, recordedSymbols, strtab);\n    let sections = [];\n    for(const section of state.sections)\n    {\n        section.index = sections.length + 1;\n        let newSection = new ELFSection({\n            type: section.type,\n            buffer: section.head.dump(),\n            flags: section.flags,\n            section,\n            entrySize: section.entrySize,\n            bitness: state.bitness\n        });\n        sections.push(newSection);\n        const relocs = section.getRelocations();\n        if(relocs.length > 0)\n        {\n            const relocSection = new RelocationSection({ infoSection: newSection, flags: 0x40, align: 8, bitness: state.bitness }, relocs, symtab);\n            relocSection.name('.rela' + section.name, shstrtab);\n            sections.push(relocSection);\n        }\n    }\n\n    if(symtab.symbols.length > 0)\n    {\n        symtab.name('.symtab', shstrtab);\n        strtab.name('.strtab', shstrtab);\n\n        sections.push(symtab, strtab);\n    }\n    sections.push(shstrtab);\n    shstrtab.name('.shstrtab', shstrtab);\n\n\n    // Finalizing\n    let fileOffset = ELFHeader.size(state.bitness);\n\n    symtab.symbols.sort((a, b) => (a.bind ?? 0) - (b.bind ?? 0) || (b.type ?? 0) - (a.type ?? 0));\n\n    for(const section of sections)\n    {\n        section.setIndices(sections);\n        const align = section.header.sh_addralign;\n        if(align)\n            fileOffset = Math.ceil(fileOffset / align) * align;\n        \n        section.header.sh_offset = fileOffset;\n        fileOffset += section.buffer.length;\n        if(section.section)\n            section.name(section.section.name, shstrtab);\n    }\n\n    // 8-byte alignment\n    let alignedFileOffset = Math.ceil(fileOffset / 8) * 8;\n\n    \n    /* Outputting */\n    outBuffer.write(new ELFHeader({\n        EI_MAG: 0x46_4C_45_7F,\n        EI_CLASS: state.bitness >> 5,\n        EI_DATA: 1,\n        EI_VERSION: 1,\n        EI_OSABI: 0,\n\n        e_type: 1, // ET_REL\n        e_machine: state.bitness === 64 ? 0x3E : 0x03,\n        e_version: 1,\n        e_shoff: alignedFileOffset,\n        e_ehsize: ELFHeader.size(state.bitness),\n        e_shentsize: SectionHeader.size(state.bitness),\n        e_shnum: sections.length + 1,\n        e_shstrndx: sections.indexOf(shstrtab) + 1\n    }).dump(state.bitness), 0);\n\n    // Writing the section buffers\n    for(const section of sections)\n        outBuffer.write(section.buffer, section.header.sh_offset);\n    \n    // Writing the headers\n    let index = alignedFileOffset + SectionHeader.size(state.bitness);\n    for(const section of sections)\n    {\n        outBuffer.write(section.header.dump(state.bitness), index);\n        index += SectionHeader.size(state.bitness);\n    }\n    \n    return outBuffer.toUint8Array();\n}\n\n/**\n * @param {AssemblyState} state\n */\nexport function createExecutable(state)\n{\n    const outBuffer = new OutputBuffer();\n\n    let entryPoint = 0, entrySection = state.sections.find(section => section.name == '.text');\n    let programHeaders = [], fileOffset = Math.ceil(ELFHeader.size(state.bitness) / 0x1000) * 0x1000, memoryOffset = 0x400000;\n    let sections = [...state.sections];\n    /** @type {import(\"@defasm/core/symbols\").Symbol[]} */\n    let commonSymbols = [];\n\n    state.symbols.forEach((symbol, name) => {\n        if(name == '_start' && symbol.bind == 1)\n        {\n            entryPoint = Number(symbol.value.absoluteValue());\n            entrySection = symbol.value.section;\n        }\n        if(symbol.value.section == pseudoSections.UND)\n            throw `Can't assemble executable: unknown symbol ${symbol.name}`;\n        \n        if(symbol.value.section == pseudoSections.COM)\n            commonSymbols.push(symbol);\n    });\n\n    for(const section of sections)\n    {\n        const data = section.head.dump();\n        outBuffer.write(data, fileOffset);\n        const header = new ProgramHeader({\n            p_type: 1,\n            p_flags:\n                (section.flags & sectionFlags.a ? 4 : 0) |\n                (section.flags & sectionFlags.w ? 2 : 0) |\n                (section.flags & sectionFlags.x ? 1 : 0),\n            p_offset: fileOffset,\n            p_vaddr: memoryOffset,\n            p_paddr: memoryOffset,\n            p_filesz: data.length,\n            p_memsz: data.length\n        });\n        programHeaders.push(header);\n        if(section == entrySection)\n            entryPoint += memoryOffset;\n        section.programHeader = header;\n        header.section = section;\n\n        let length = data.length || 1;\n        fileOffset = Math.ceil((fileOffset + length) / 0x1000) * 0x1000;\n        memoryOffset = Math.ceil((memoryOffset + length) / 0x1000) * 0x1000;\n    }\n\n    const bss = sections.find(section => section.name == '.bss').programHeader;\n    if(commonSymbols.length > 0)\n    {\n        let sectionSize = bss.p_memsz;\n        for(const symbol of commonSymbols)\n        {\n            const alignment = Number(symbol.value.addend) || 1;\n            sectionSize = Math.ceil(sectionSize / alignment) * alignment;\n            symbol.address = sectionSize;\n            sectionSize += Number(symbol.size);\n        }\n        bss.p_memsz = sectionSize;\n    }\n    \n    outBuffer.write(new ELFHeader({\n        EI_MAG: 0x46_4C_45_7F,\n        EI_CLASS: state.bitness >> 5,\n        EI_DATA: 1,\n        EI_VERSION: 1,\n        EI_OSABI: 0,\n\n        e_type: 2, // ET_EXEC\n        e_machine: state.bitness === 64 ? 0x3E : 0x03,\n        e_version: 1,\n        e_entry: entryPoint,\n        e_phoff: fileOffset,\n        e_ehsize: ELFHeader.size(state.bitness),\n        e_phentsize: ProgramHeader.size(state.bitness),\n        e_phnum: programHeaders.length\n    }).dump(state.bitness), 0);\n\n    // Writing the program headers\n    for(const header of programHeaders)\n    {\n        outBuffer.write(header.dump(state.bitness), fileOffset);\n        fileOffset += ProgramHeader.size(state.bitness);\n    }\n\n    // Applying the relocations\n    for(const section of state.sections) for(const reloc of section.getRelocations())\n    {\n        const offset = section.programHeader.p_vaddr + reloc.offset;\n        const buffer = Buffer.alloc(reloc.size / 8);\n        let value = reloc.addend + (reloc.symbol.value.section == pseudoSections.COM ? \n                BigInt(reloc.symbol.address + bss.p_vaddr)\n            :\n                reloc.symbol?.value ?\n                    reloc.symbol.value.absoluteValue() + BigInt(reloc.symbol.value.section.programHeader.p_vaddr)\n                :\n                    0n\n        );\n        \n        if(reloc.pcRelative)\n            value -= BigInt(offset);\n        let bigInt = reloc.size == 64;\n        value = value & (1n << BigInt(reloc.size)) - 1n;\n        buffer[`write${bigInt ? 'Big' : ''}${reloc.signed ? '' : 'U'}Int${reloc.size}${reloc.size > 8 ? 'LE' : ''}`](bigInt ? value : Number(value));\n\n        outBuffer.write(buffer, section.programHeader.p_offset + reloc.offset);\n    }\n\n    return outBuffer.toUint8Array();\n}\n"],
  "mappings": "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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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",
  "names": ["code", "len", "i", "len2", "Buffer", "i", "byteLength", "code", "state", "state", "instr", "line", "instr", "addr", "instr", "instr", "instr", "instr", "reg", "suffixes", "line", "op", "instr", "line", "import_buffer", "state", "sections", "header", "addr", "om", "state"]
}
